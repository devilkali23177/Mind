<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Mind Map with Firebase Integration</title>
  <!-- Add Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <style>
    /* Your existing CSS styles remain unchanged */
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #111; 
      color: #fff; 
      touch-action: none;
    }
    #toolbar { 
      padding: 8px; 
      background: #222; 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      z-index: 10; 
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    #toolbar button, #toolbar select, #toolbar input { 
      padding: 10px 14px;
      background: #444; 
      color: white;
      border: 1px solid #666;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      min-height: 20px;
    }
    #toolbar button:hover, #toolbar select:hover {
      background: #555;
    }
    #toolbar button.active {
      background: #2a6b9b;
    }
    #toolbar input {
      background: #333;
      width: 100px;
      min-height: 20px;
    }
    #toolbar .separator {
      width: 1px;
      background: #444;
      margin: 0 8px;
      height: 24px;
    }
    #stage { 
      position: absolute; 
      top: 50px;
      left: 0; 
      right: 0; 
      bottom: 0; 
      overflow: auto; 
      -webkit-overflow-scrolling: touch;
    }
    #world { 
      position: relative; 
      width: 100000000000000000000000000000000000000000000000000000000000000000000px; 
      height: 100000000000000000000000000000000000000000000000000000000000000000000px; 
      transform-origin: 0 0;
    }
    .node { 
      position: absolute; 
      min-width: 130px;
      max-width: 250px;
      padding: 12px 16px;
      background: #333; 
      border: 2px solid #666;
      border-radius: 10px;
      cursor: grab; 
      user-select: none; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      overflow: hidden;
      text-overflow: ellipsis;
      transition: transform 0.1s ease;
      font-size: 16px;
      touch-action: none;
    }
    .node:hover {
      transform: scale(1.02);
    }
    .node.selected { 
      border-color: #0ff; 
      box-shadow: 0 0 10px rgba(0,255,255,0.5);
    }
    .node.dragging {
      cursor: grabbing;
      opacity: 0.9;
    }
    .node.connecting {
      border-color: #ff0;
      box-shadow: 0 0 10px rgba(255,255,0,0.5);
    }
    .node.connection-source {
      border-color: #0f0;
      box-shadow: 0 0 10px rgba(0,255,0,0.5);
    }
    .node-content {
      min-height: 24px;
      word-wrap: break-word;
    }
    svg { 
      position: absolute; 
      inset: 0; 
      pointer-events: none; 
    }
    line.connection {
      stroke: #0ff;
      stroke-width: 2;
    }
    line.connection.highlight {
      stroke: #ff0;
      stroke-width: 3;
    }
    #zoom-display {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 5;
    }
    .context-menu {
      position: fixed;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      z-index: 100;
      min-width: 150px;
    }
    .context-menu-item {
      padding: 12px 16px;
      cursor: pointer;
      font-size: 16px;
    }
    .context-menu-item:hover {
      background: #444;
    }
    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 10px;
      width: 140px;
    }
    .color-option {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #555;
    }
    .node-edit-input {
      position: absolute;
      background: #222;
      border: 2px solid #0ff;
      border-radius: 6px;
      padding: 8px;
      color: white;
      font: inherit;
      z-index: 20;
      min-width: 120px;
      resize: both;
      overflow: auto;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      font-size: 16px;
    }
    #edit-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      border: 2px solid #0ff;
      border-radius: 8px;
      padding: 20px;
      z-index: 100;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      width: 320px;
      display: none;
    }
    #edit-panel h3 {
      margin-top: 0;
      color: #0ff;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
      font-size: 18px;
    }
    #edit-textarea {
      width: 100%;
      height: 120px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 10px;
      resize: vertical;
      margin-bottom: 15px;
      font-family: inherit;
      font-size: 16px;
    }
    #edit-panel-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    #edit-panel button {
      padding: 10px 18px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      min-width: 80px;
    }
    #edit-panel-save {
      background: #2a6b9b;
      color: white;
    }
    #edit-panel-cancel {
      background: #555;
      color: white;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 90;
      display: none;
    }
    
    /* Firebase auth UI */
    #auth-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #auth-box {
      background: #333;
      padding: 30px;
      border-radius: 10px;
      width: 300px;
      text-align: center;
    }
    #auth-box h2 {
      margin-top: 0;
      color: #0ff;
    }
    #auth-box input {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: 1px solid #555;
      border-radius: 4px;
      background: #222;
      color: white;
      box-sizing: border-box;
    }
    #auth-box button {
      width: 100%;
      padding: 12px;
      margin: 5px 0;
      border: none;
      border-radius: 4px;
      background: #2a6b9b;
      color: white;
      cursor: pointer;
    }
    #auth-box p {
      margin: 15px 0 5px;
      color: #aaa;
    }
    #auth-message {
      color: #e74c3c;
      margin: 10px 0;
      min-height: 20px;
    }
    
    /* Mind Map Manager UI */
    #map-manager-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    #map-manager-box {
      background: #333;
      padding: 30px;
      border-radius: 10px;
      width: 500px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
    }
    #map-manager-box h2 {
      margin-top: 0;
      color: #0ff;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
    }
    #map-list {
      margin: 20px 0;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #555;
      border-radius: 4px;
      background: #222;
    }
    .map-item {
      padding: 12px 16px;
      border-bottom: 1px solid #444;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .map-item:hover {
      background: #3a3a3a;
    }
    .map-item.active {
      background: #2a6b9b;
    }
    .map-item-actions {
      display: flex;
      gap: 8px;
    }
    .map-item-actions button {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .map-item-actions .delete-btn {
      background: #e74c3c;
      color: white;
    }
    .map-item-actions .rename-btn {
      background: #f39c12;
      color: white;
    }
    #new-map-form {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }
    #new-map-input {
      flex: 1;
      padding: 10px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }
    #create-map-btn {
      padding: 10px 16px;
      background: #2ecc71;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #close-map-manager {
      width: 100%;
      padding: 12px;
      background: #555;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    
    /* Connection line preview */
    #connection-preview {
      position: absolute;
      pointer-events: none;
      z-index: 5;
      display: none;
    }
    
    /* Connection mode indicator */
    #connection-mode-indicator {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 0, 0.8);
      color: #000;
      padding: 8px 16px;
      border-radius: 4px;
      z-index: 10;
      font-weight: bold;
      display: none;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      #toolbar {
        padding: 6px;
        gap: 4px;
        overflow-x: auto;
        white-space: nowrap;
        height: 44px;
      }
      #toolbar button, #toolbar select, #toolbar input {
        padding: 8px 10px;
        font-size: 13px;
      }
      #stage {
        top: 46px;
      }
      .node {
        min-width: 110px;
        padding: 10px 12px;
        font-size: 15px;
      }
      #zoom-display {
        bottom: 5px;
        right: 5px;
        font-size: 12px;
        padding: 4px 8px;
      }
      #auth-box {
        width: 90%;
        max-width: 300px;
      }
      #map-manager-box {
        width: 90%;
        padding: 20px;
      }
      .map-item {
        padding: 10px 12px;
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .map-item-actions {
        align-self: flex-end;
      }
      #connection-mode-indicator {
        top: 50px;
        font-size: 14px;
        padding: 6px 12px;
      }
    }
    
    /* Prevent text selection on UI elements */
    .node, #toolbar button, .context-menu-item {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* Long press detection style */
    .long-press {
      animation: pulse 0.8s infinite alternate;
    }
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }
  </style>
</head>
<body>
  <!-- Firebase Auth UI -->
  <div id="auth-container">
    <div id="auth-box">
      <h2>Mind Map Login</h2>
      <div id="auth-message"></div>
      <input type="email" id="email-input" placeholder="Email">
      <input type="password" id="password-input" placeholder="Password">
      <button id="login-btn">Login</button>
      <button id="signup-btn">Sign Up</button>
      <p>Or continue as</p>
      <button id="guest-btn">Guest</button>
    </div>
  </div>

  <!-- Mind Map Manager UI -->
  <div id="map-manager-container">
    <div id="map-manager-box">
      <h2>Manage Mind Maps</h2>
      <div id="new-map-form">
        <input type="text" id="new-map-input" placeholder="New map name">
        <button id="create-map-btn">Create New Map</button>
      </div>
      <div id="map-list">
        <!-- Map items will be added here dynamically -->
      </div>
      <button id="close-map-manager">Close</button>
    </div>
  </div>

  <!-- Connection mode indicator -->
  <div id="connection-mode-indicator">Connection Mode: Click on a node to start connecting</div>

  <div id="toolbar">
    <button id="addBtn">Add Node</button>
    <button id="connectBtn">Connect Nodes</button>
    <button id="editBtn">Edit Node</button>
    <button id="deleteBtn">Delete</button>
    <div class="separator"></div>
    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
    <button id="resetViewBtn">Reset View</button>
    <div class="separator"></div>
    <button id="colorBtn">Color</button>
    <button id="exportBtn">Export</button>
    <button id="importBtn">Import</button>
    <div class="separator"></div>
    <select id="layoutBtn">
      <option value="">Layout</option>
      <option value="horizontal">Horizontal</option>
      <option value="vertical">Vertical</option>
      <option value="radial">Radial</option>
    </select>
    <input type="text" id="searchInput" placeholder="Search nodes...">
    <div class="separator"></div>
    <button id="saveBtn">Save to Cloud</button>
    <button id="loadBtn">Load from Cloud</button>
    <button id="mapsBtn">Manage Maps</button>
    <button id="logoutBtn" style="display:none;">Logout</button>
  </div>
  <div id="stage">
    <div id="world">
      <svg id="edges" width="100000000000000000000000000000000000000000000000000000000000000000000" height="100000000000000000000000000000000000000000000000000000000000000000000"></svg>
      <svg id="connection-preview"></svg>
    </div>
  </div>
  <div id="zoom-display">100%</div>
  
  <!-- Edit Panel -->
  <div id="overlay"></div>
  <div id="edit-panel">
    <h3>Edit Node Content</h3>
    <textarea id="edit-textarea"></textarea>
    <div id="edit-panel-buttons">
      <button id="edit-panel-cancel">Cancel</button>
      <button id="edit-panel-save">Save</button>
    </div>
  </div>
  
  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBlQI16Nmx5oo3VzyCDEb6V4M2cH9Bbwc8",
      authDomain: "mindmapping-58435.firebaseapp.com",
      databaseURL: "https://mindmapping-58435-default-rtdb.firebaseio.com",
      projectId: "mindmapping-58435",
      storageBucket: "mindmapping-58435.firebasestorage.app",
      messagingSenderId: "1059085761579",
      appId: "1:1059085761579:web:5422cefb56f5989af7be6e",
      measurementId: "G-9F7EZZ2C9T"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const auth = firebase.auth();
    
    // Main application variables
    const world = document.getElementById('world');
    const edgesSVG = document.getElementById('edges');
    const connectionPreview = document.getElementById('connection-preview');
    const connectionModeIndicator = document.getElementById('connection-mode-indicator');
    let nodes = {};
    let edges = [];
    let idCounter = 1;
    let connectMode = false;
    let editMode = false;
    let connectFrom = null;
    let selectedNode = null;
    let scale = 1;
    let panning = false;
    let startX, startY;
    let initialPinchDistance = null;
    let lastX = 0, lastY = 0;
    let activeEditInput = null;
    let longPressTimer = null;
    let isLongPress = false;
    let currentUser = null;
    let currentMapId = 'default';
    let mindMaps = {}; // Store all user's mind maps
    
    // New variables for fixing node dragging
    let isDraggingNode = false;
    let initialTouchPositions = null;
    
    // Initialize the application
    function init() {
      // Setup auth event listeners
      setupAuthEventListeners();
      
      // Check if user was previously logged in
      const savedUser = localStorage.getItem('mindmap_user');
      if (savedUser) {
        try {
          currentUser = JSON.parse(savedUser);
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          initApp();
        } catch (e) {
          console.error('Error parsing saved user:', e);
          localStorage.removeItem('mindmap_user');
        }
      }
    }
    
    // Initialize the app after authentication
    function initApp() {
      // Add event listeners
      setupEventListeners();
      
      // Load list of mind maps
      loadMindMapsList();
      
      // Try to load from Firebase
      loadFromFirebase();
      
      // If no data, add initial node
      if (Object.keys(nodes).length === 0) {
        addNode(500, 500, 'Main Topic');
      }
      
      // Update zoom display
      updateZoomDisplay();
    }
    
    // Set up authentication event listeners
    function setupAuthEventListeners() {
      document.getElementById('login-btn').onclick = handleLogin;
      document.getElementById('signup-btn').onclick = handleSignup;
      document.getElementById('guest-btn').onclick = handleGuest;
      document.getElementById('logoutBtn').onclick = handleLogout;
      
      // Allow submitting with Enter key
      document.getElementById('email-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLogin();
      });
      document.getElementById('password-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLogin();
      });
    }
    
    // Handle user login
    function handleLogin() {
      const email = document.getElementById('email-input').value;
      const password = document.getElementById('password-input').value;
      const authMessage = document.getElementById('auth-message');
      
      if (!email || !password) {
        authMessage.textContent = 'Please enter both email and password';
        return;
      }
      
      authMessage.textContent = 'Logging in...';
      
      auth.signInWithEmailAndPassword(email, password)
        .then((userCredential) => {
          currentUser = userCredential.user;
          localStorage.setItem('mindmap_user', JSON.stringify({
            uid: currentUser.uid,
            email: currentUser.email
          }));
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          authMessage.textContent = '';
          initApp();
        })
        .catch((error) => {
          authMessage.textContent = error.message;
        });
    }
    
    // Handle user signup
    function handleSignup() {
      const email = document.getElementById('email-input').value;
      const password = document.getElementById('password-input').value;
      const authMessage = document.getElementById('auth-message');
      
      if (!email || !password) {
        authMessage.textContent = 'Please enter both email and password';
        return;
      }
      
      if (password.length < 6) {
        authMessage.textContent = 'Password should be at least 6 characters';
        return;
      }
      
      authMessage.textContent = 'Creating account...';
      
      auth.createUserWithEmailAndPassword(email, password)
        .then((userCredential) => {
          currentUser = userCredential.user;
          localStorage.setItem('mindmap_user', JSON.stringify({
            uid: currentUser.uid,
            email: currentUser.email
          }));
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          authMessage.textContent = '';
          initApp();
        })
        .catch((error) => {
          authMessage.textContent = error.message;
        });
    }
    
    // Handle guest access
    function handleGuest() {
      currentUser = { uid: 'guest', email: 'guest@example.com' };
      document.getElementById('auth-container').style.display = 'none';
      initApp();
    }
    
    // Handle user logout
    function handleLogout() {
      auth.signOut().then(() => {
        currentUser = null;
        localStorage.removeItem('mindmap_user');
        document.getElementById('logoutBtn').style.display = 'none';
        document.getElementById('auth-container').style.display = 'flex';
        
        // Clear current mind map
        nodes = {};
        edges = [];
        idCounter = 1;
        world.querySelectorAll('.node').forEach(n => n.remove());
        edgesSVG.innerHTML = '';
        clearSelection();
      }).catch((error) => {
        console.error('Logout error:', error);
      });
    }
    
    // Set up all event listeners
    function setupEventListeners() {
      // Toolbar buttons
      document.getElementById('addBtn').onclick = () => {
        const x = 500 + Math.random() * 400;
        const y = 500 + Math.random() * 400;
        addNode(x, y, 'New Node');
        saveToFirebase(); // Auto-save after adding node
      };
      
      document.getElementById('connectBtn').onclick = () => {
        toggleConnectMode();
      };
      
      document.getElementById('editBtn').onclick = () => {
        editMode = !editMode;
        connectMode = false;
        document.getElementById('editBtn').classList.toggle('active', editMode);
        document.getElementById('connectBtn').classList.remove('active');
        
        // Clear any connection in progress
        resetConnectionMode();
        
        // Show instructions if edit mode is enabled
        if (editMode) {
          alert('Edit mode: Click on any node to edit its content.');
        }
      };
      
      document.getElementById('deleteBtn').onclick = () => {
        deleteSelected();
        saveToFirebase(); // Auto-save after deletion
      };
      
      document.getElementById('zoomInBtn').onclick = () => adjustZoom(0.1);
      document.getElementById('zoomOutBtn').onclick = () => adjustZoom(-0.1);
      document.getElementById('resetViewBtn').onclick = resetView;
      
      document.getElementById('colorBtn').onclick = showColorMenu;
      document.getElementById('exportBtn').onclick = exportData;
      document.getElementById('importBtn').onclick = () => document.getElementById('importInput')?.click() || createImportInput();
      
      document.getElementById('layoutBtn').onchange = (e) => {
        if (e.target.value) {
          applyLayout(e.target.value);
          saveToFirebase(); // Auto-save after layout change
        }
      };
      
      document.getElementById('searchInput').oninput = (e) => {
        searchNodes(e.target.value);
      };
      
      // Firebase save/load buttons
      document.getElementById('saveBtn').onclick = saveToFirebase;
      document.getElementById('loadBtn').onclick = loadFromFirebase;
      
      // Map management button
      document.getElementById('mapsBtn').onclick = showMapManager;
      
      // Edit panel buttons
      document.getElementById('edit-panel-save').onclick = () => {
        saveEditPanel();
        saveToFirebase(); // Auto-save after editing
      };
      document.getElementById('edit-panel-cancel').onclick = closeEditPanel;
      document.getElementById('overlay').onclick = closeEditPanel;
      
      // Map manager event listeners
      document.getElementById('create-map-btn').onclick = createNewMap;
      document.getElementById('close-map-manager').onclick = hideMapManager;
      
      // Allow Enter key to create new map
      document.getElementById('new-map-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') createNewMap();
      });
      
      // Panning and zooming
      world.addEventListener('wheel', handleWheel, { passive: false });
      world.addEventListener('mousedown', startPan);
      document.addEventListener('mousemove', handlePan);
      document.addEventListener('mouseup', stopPan);
      
      // Touch events for mobile
      setupTouchEvents();
      
      // Context menu
      world.addEventListener('contextmenu', handleContextMenu);
      
      // Click outside to clear selection
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.node') && !e.target.closest('.context-menu') && 
            !e.target.closest('.node-edit-input') && !e.target.closest('#edit-panel') &&
            !e.target.closest('#map-manager-container')) {
          clearSelection();
          hideContextMenu();
        }
      });
      
      // Double click to edit
      world.addEventListener('dblclick', (e) => {
        const node = e.target.closest('.node');
        if (node) {
          const nodeId = node.dataset.id;
          selectNode(nodeId);
          showEditPanel(nodes[nodeId]);
        }
      });
      
      // Auto-save on node drag end
      document.addEventListener('mouseup', () => {
        if (isDraggingNode) {
          saveToFirebase();
          isDraggingNode = false;
        }
      });
      
      // Improved connection mode handling
      document.addEventListener('mousemove', handleConnectionPreview);
    }
    
    // Toggle connection mode
    function toggleConnectMode() {
      connectMode = !connectMode;
      editMode = false;
      document.getElementById('connectBtn').classList.toggle('active', connectMode);
      document.getElementById('editBtn').classList.remove('active');
      
      if (connectMode) {
        // Show connection instructions
        connectionModeIndicator.style.display = 'block';
        connectionModeIndicator.textContent = 'Connection Mode: Click on a node to start connecting';
        
        // Highlight all nodes to indicate they're connectable
        document.querySelectorAll('.node').forEach(node => {
          node.classList.add('connecting');
        });
      } else {
        // Exit connection mode
        resetConnectionMode();
      }
      
      clearSelection();
    }
    
    // Reset connection mode to initial state
    function resetConnectionMode() {
      connectFrom = null;
      clearConnectionPreview();
      connectionModeIndicator.style.display = 'none';
      
      document.querySelectorAll('.node.connecting, .node.connection-source').forEach(node => {
        node.classList.remove('connecting');
        node.classList.remove('connection-source');
      });
    }
    
    // Handle connection preview line
    function handleConnectionPreview(e) {
      if (!connectMode || !connectFrom) return;
      
      const fromNode = nodes[connectFrom];
      if (!fromNode) return;
      
      // Get mouse position relative to world
      const rect = world.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) / scale;
      const mouseY = (e.clientY - rect.top) / scale;
      
      // Draw preview line
      clearConnectionPreview();
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('class', 'connection');
      line.setAttribute('x1', fromNode.x + 65);
      line.setAttribute('y1', fromNode.y + 20);
      line.setAttribute('x2', mouseX);
      line.setAttribute('y2', mouseY);
      line.setAttribute('stroke-dasharray', '5,5');
      
      connectionPreview.appendChild(line);
      connectionPreview.style.display = 'block';
    }
    
    // Clear connection preview
    function clearConnectionPreview() {
      connectionPreview.innerHTML = '';
      connectionPreview.style.display = 'none';
    }
    
    // Save mind map to Firebase
    function saveToFirebase() {
      if (!currentUser) return;
      
      const data = {
        nodes: Object.values(nodes),
        edges: edges,
        idCounter: idCounter,
        lastUpdated: Date.now(),
        name: currentMapId === 'default' ? 'Default Map' : currentMapId
      };
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${currentMapId}`).set(data)
        .then(() => {
          console.log('Data saved successfully to Firebase');
          // Show a temporary save confirmation
          const saveBtn = document.getElementById('saveBtn');
          const originalText = saveBtn.textContent;
          saveBtn.textContent = 'Saved!';
          setTimeout(() => {
            saveBtn.textContent = originalText;
          }, 2000);
          
          // Refresh the map list to show updated timestamp
          loadMindMapsList();
        })
        .catch((error) => {
          console.error('Error saving data to Firebase:', error);
          alert('Failed to save to cloud: ' + error.message);
        });
    }
    
    // Load mind map from Firebase
    function loadFromFirebase() {
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${currentMapId}`).once('value')
        .then((snapshot) => {
          const data = snapshot.val();
          if (data) {
            loadData(data);
            console.log('Data loaded successfully from Firebase');
          } else {
            console.log('No data found in Firebase, using local data');
            // Create a new empty map if none exists
            if (Object.keys(nodes).length === 0) {
              addNode(500, 500, 'Main Topic');
            }
          }
        })
        .catch((error) => {
          console.error('Error loading data from Firebase:', error);
          alert('Failed to load from cloud: ' + error.message);
        });
    }
    
    // Load list of all mind maps for the current user
    function loadMindMapsList() {
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(userPath).once('value')
        .then((snapshot) => {
          const maps = snapshot.val();
          mindMaps = maps || {};
          renderMapsList();
        })
        .catch((error) => {
          console.error('Error loading mind maps list:', error);
        });
    }
    
    // Render the list of mind maps in the manager UI
    function renderMapsList() {
      const mapList = document.getElementById('map-list');
      mapList.innerHTML = '';
      
      if (!mindMaps || Object.keys(mindMaps).length === 0) {
        mapList.innerHTML = '<div class="map-item" style="justify-content: center; cursor: default;">No maps found</div>';
        return;
      }
      
      Object.entries(mindMaps).forEach(([mapId, mapData]) => {
        const mapItem = document.createElement('div');
        mapItem.className = 'map-item';
        if (mapId === currentMapId) {
          mapItem.classList.add('active');
        }
        
        const mapName = document.createElement('div');
        mapName.className = 'map-name';
        mapName.textContent = mapData.name || mapId;
        
        const mapInfo = document.createElement('div');
        mapInfo.className = 'map-info';
        mapInfo.textContent = new Date(mapData.lastUpdated).toLocaleString();
        
        const mapActions = document.createElement('div');
        mapActions.className = 'map-item-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.onclick = (e) => {
          e.stopPropagation();
          loadMap(mapId);
          hideMapManager();
        };
        
        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'Rename';
        renameBtn.className = 'rename-btn';
        renameBtn.onclick = (e) => {
          e.stopPropagation();
          renameMap(mapId);
        };
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.className = 'delete-btn';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteMap(mapId);
        };
        
        mapActions.appendChild(loadBtn);
        mapActions.appendChild(renameBtn);
        mapActions.appendChild(deleteBtn);
        
        mapItem.appendChild(mapName);
        mapItem.appendChild(mapInfo);
        mapItem.appendChild(mapActions);
        
        mapItem.onclick = () => {
          loadMap(mapId);
          hideMapManager();
        };
        
        mapList.appendChild(mapItem);
      });
    }
    
    // Load a specific mind map
    function loadMap(mapId) {
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}`).once('value')
        .then((snapshot) => {
          const data = snapshot.val();
          if (data) {
            currentMapId = mapId;
            loadData(data);
            console.log(`Map "${mapId}" loaded successfully`);
          } else {
            console.error(`Map "${mapId}" not found`);
          }
        })
        .catch((error) => {
          console.error('Error loading map:', error);
          alert('Failed to load map: ' + error.message);
        });
    }
    
    // Create a new mind map
    function createNewMap() {
      const mapNameInput = document.getElementById('new-map-input');
      const mapName = mapNameInput.value.trim();
      
      if (!mapName) {
        alert('Please enter a map name');
        return;
      }
      
      if (!currentUser) return;
      
      // Create a unique ID for the map
      const mapId = mapName.toLowerCase().replace(/\s+/g, '_') + '_' + Date.now();
      
      // Create initial data for the new map
      const initialData = {
        nodes: [{ id: 1, x: 500, y: 500, text: 'Main Topic', color: '#333' }],
        edges: [],
        idCounter: 1,
        lastUpdated: Date.now(),
        name: mapName
      };
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}`).set(initialData)
        .then(() => {
          console.log('New map created successfully');
          mapNameInput.value = '';
          
          // Reload the maps list
          loadMindMapsList();
          
          // Load the new map
          loadMap(mapId);
          hideMapManager();
        })
        .catch((error) => {
          console.error('Error creating new map:', error);
          alert('Failed to create new map: ' + error.message);
        });
    }
    
    // Rename a mind map
    function renameMap(mapId) {
      const newName = prompt('Enter new name for this map:', mindMaps[mapId].name || mapId);
      if (!newName || newName.trim() === '') return;
      
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}/name`).set(newName.trim())
        .then(() => {
          console.log('Map renamed successfully');
          loadMindMapsList(); // Refresh the list
        })
        .catch((error) => {
          console.error('Error renaming map:', error);
          alert('Failed to rename map: ' + error.message);
        });
    }
    
    // Delete a mind map
    function deleteMap(mapId) {
      if (!confirm(`Are you sure you want to delete "${mindMaps[mapId].name || mapId}"?`)) return;
      
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}`).remove()
        .then(() => {
          console.log('Map deleted successfully');
          
          // If we deleted the current map, switch to default
          if (mapId === currentMapId) {
            currentMapId = 'default';
            loadFromFirebase();
          }
          
          loadMindMapsList(); // Refresh the list
        })
        .catch((error) => {
          console.error('Error deleting map:', error);
          alert('Failed to delete map: ' + error.message);
        });
    }
    
    // Show the map manager UI
    function showMapManager() {
      document.getElementById('map-manager-container').style.display = 'flex';
      loadMindMapsList();
    }
    
    // Hide the map manager UI
    function hideMapManager() {
      document.getElementById('map-manager-container').style.display = 'none';
    }
    
    // Load data into the application
    function loadData(data) {
      // Clear existing nodes and edges
      nodes = {};
      edges = data.edges || [];
      idCounter = data.idCounter || 1;
      
      world.querySelectorAll('.node').forEach(n => n.remove());
      edgesSVG.innerHTML = '';
      
      // Create nodes
      if (data.nodes && data.nodes.length > 0) {
        data.nodes.forEach(nodeData => {
          createNodeFromData(nodeData);
        });
      } else {
        // Fallback if no nodes in data
        addNode(500, 500, 'Main Topic');
      }
      
      // Draw edges
      redrawEdges();
      
      // Reset view
      resetView();
    }
    
    // Create a node from saved data
    function createNodeFromData(nodeData) {
      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = nodeData.id;
      node.style.left = nodeData.x + 'px';
      node.style.top = nodeData.y + 'px';
      node.style.backgroundColor = nodeData.color || '#333';
      
      const content = document.createElement('div');
      content.className = 'node-content';
      content.textContent = nodeData.text || '';
      
      node.appendChild(content);
      world.appendChild(node);
      
      // Store node in our data structure
      nodes[nodeData.id] = {
        id: nodeData.id,
        x: nodeData.x,
        y: nodeData.y,
        text: nodeData.text || '',
        color: nodeData.color || '#333'
      };
      
      // Add event listeners to the node
      setupNodeEventListeners(node);
    }
    
    // Set up event listeners for a node
    function setupNodeEventListeners(node) {
      const nodeId = node.dataset.id;
      
      // Click event for selection and connection
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        
        if (connectMode) {
          handleNodeConnection(nodeId);
        } else if (editMode) {
          selectNode(nodeId);
          showEditPanel(nodes[nodeId]);
        } else {
          selectNode(nodeId);
        }
      });
      
      // Mouse down for dragging
      node.addEventListener('mousedown', startNodeDrag);
      
      // Touch events for mobile
      node.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
      node.addEventListener('touchmove', handleNodeTouchMove, { passive: false });
      node.addEventListener('touchend', handleNodeTouchEnd);
      node.addEventListener('touchcancel', handleNodeTouchEnd);
      
      // Long press for context menu on mobile
      node.addEventListener('touchstart', handleLongPressStart);
      node.addEventListener('touchend', handleLongPressEnd);
      node.addEventListener('touchmove', handleLongPressEnd);
    }
    
    // Handle node connection logic
    function handleNodeConnection(nodeId) {
      if (!connectFrom) {
        // First node selected for connection
        connectFrom = nodeId;
        document.querySelectorAll('.node').forEach(n => {
          n.classList.remove('connecting');
          if (n.dataset.id === nodeId) {
            n.classList.add('connection-source');
          }
        });
        connectionModeIndicator.textContent = 'Connection Mode: Now click on a node to connect to';
      } else {
        // Second node selected - create connection
        if (connectFrom !== nodeId) {
          // Check if connection already exists
          const connectionExists = edges.some(edge => 
            (edge.from === connectFrom && edge.to === nodeId) || 
            (edge.from === nodeId && edge.to === connectFrom)
          );
          
          if (!connectionExists) {
            edges.push({ from: connectFrom, to: nodeId });
            redrawEdges();
            saveToFirebase(); // Auto-save after creating connection
          }
        }
        
        // Reset connection mode
        resetConnectionMode();
        
        // If connection mode is still active, keep the connection UI
        if (connectMode) {
          document.querySelectorAll('.node').forEach(n => {
            n.classList.add('connecting');
          });
        }
      }
    }
    
    // Handle node touch start event
    function handleNodeTouchStart(e) {
      e.stopPropagation();
      
      if (e.touches.length === 1) {
        // Single touch - prepare for potential drag or long press
        const touch = e.touches[0];
        const node = e.currentTarget;
        const nodeId = node.dataset.id;
        
        // Prevent default to avoid browser interactions
        e.preventDefault();
        
        // Select the node
        selectNode(nodeId);
        
        // Store initial touch position for dragging
        initialTouchPositions = {
          nodeX: nodes[nodeId].x,
          nodeY: nodes[nodeId].y,
          touchX: touch.clientX,
          touchY: touch.clientY,
          scrollLeft: world.scrollLeft,
          scrollTop: world.scrollTop
        };
        
        // Start long press timer
        isLongPress = false;
        longPressTimer = setTimeout(() => {
          isLongPress = true;
          showContextMenu(e, nodeId);
        }, 500);
      } else if (e.touches.length === 2) {
        // Two-finger touch - cancel any pending actions
        clearTimeout(longPressTimer);
        isLongPress = false;
      }
    }
    
    // Handle node touch move event
    function handleNodeTouchMove(e) {
      if (e.touches.length === 1 && initialTouchPositions) {
        // Single touch moving - drag the node
        e.preventDefault();
        e.stopPropagation();
        
        clearTimeout(longPressTimer);
        isLongPress = false;
        
        const touch = e.touches[0];
        const node = e.currentTarget;
        const nodeId = node.dataset.id;
        
        // Calculate new position
        const deltaX = (touch.clientX - initialTouchPositions.touchX) / scale;
        const deltaY = (touch.clientY - initialTouchPositions.touchY) / scale;
        
        const newX = initialTouchPositions.nodeX + deltaX;
        const newY = initialTouchPositions.nodeY + deltaY;
        
        // Update node position
        moveNode(nodeId, newX, newY);
        
        // Redraw connections
        redrawEdges();
      }
    }
    
    // Handle node touch end event
    function handleNodeTouchEnd(e) {
      e.stopPropagation();
      
      if (e.touches.length === 0 && initialTouchPositions) {
        // Touch ended - check if it was a tap or long press
        clearTimeout(longPressTimer);
        
        if (!isLongPress) {
          // It was a tap, handle based on current mode
          const nodeId = e.currentTarget.dataset.id;
          
          if (connectMode) {
            handleNodeConnection(nodeId);
          } else if (editMode) {
            showEditPanel(nodes[nodeId]);
          }
          // For selection, it's already handled in touchstart
        }
        
        // Reset touch state
        initialTouchPositions = null;
        isLongPress = false;
        
        // Save after dragging
        saveToFirebase();
      }
    }
    
    // Handle long press start
    function handleLongPressStart(e) {
      if (e.touches.length === 1) {
        const node = e.currentTarget;
        node.classList.add('long-press');
        
        longPressTimer = setTimeout(() => {
          const nodeId = node.dataset.id;
          showContextMenu(e, nodeId);
        }, 500);
      }
    }
    
    // Handle long press end
    function handleLongPressEnd(e) {
      clearTimeout(longPressTimer);
      document.querySelectorAll('.node').forEach(n => {
        n.classList.remove('long-press');
      });
    }
    
    // Set up touch events for the stage
    function setupTouchEvents() {
      const stage = document.getElementById('stage');
      
      stage.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          // Two-finger touch for zooming
          e.preventDefault();
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          
          initialPinchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
        } else if (e.touches.length === 1 && !e.target.closest('.node')) {
          // Single finger touch on stage (not on a node) for panning
          const touch = e.touches[0];
          startX = touch.clientX;
          startY = touch.clientY;
          lastX = world.scrollLeft;
          lastY = world.scrollTop;
          panning = true;
        }
      }, { passive: false });
      
      stage.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2 && initialPinchDistance !== null) {
          // Two-finger pinch zoom
          e.preventDefault();
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          
          const currentDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          
          const delta = currentDistance - initialPinchDistance;
          
          if (Math.abs(delta) > 5) {
            adjustZoom(delta * 0.01);
            initialPinchDistance = currentDistance;
          }
        } else if (e.touches.length === 1 && panning) {
          // Single finger panning
          e.preventDefault();
          
          const touch = e.touches[0];
          const dx = touch.clientX - startX;
          const dy = touch.clientY - startY;
          
          world.scrollLeft = lastX - dx;
          world.scrollTop = lastY - dy;
        }
      }, { passive: false });
      
      stage.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
          initialPinchDistance = null;
        }
        if (e.touches.length === 0) {
          panning = false;
        }
      });
    }
    
    // Start node dragging with mouse
    function startNodeDrag(e) {
      if (e.button !== 0) return; // Only left click
      
      e.stopPropagation();
      const node = e.target.closest('.node');
      if (!node) return;
      
      const nodeId = node.dataset.id;
      selectNode(nodeId);
      
      node.classList.add('dragging');
      isDraggingNode = true;
      
      const startX = e.clientX;
      const startY = e.clientY;
      const startLeft = nodes[nodeId].x;
      const startTop = nodes[nodeId].y;
      
      function handleMouseMove(e) {
        const dx = (e.clientX - startX) / scale;
        const dy = (e.clientY - startY) / scale;
        
        moveNode(nodeId, startLeft + dx, startTop + dy);
        redrawEdges();
      }
      
      function handleMouseUp() {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        node.classList.remove('dragging');
        isDraggingNode = false;
        saveToFirebase(); // Auto-save after dragging
      }
      
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }
    
    // Move a node to a new position
    function moveNode(nodeId, x, y) {
      const node = nodes[nodeId];
      if (!node) return;
      
      node.x = x;
      node.y = y;
      
      const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
      if (nodeElement) {
        nodeElement.style.left = x + 'px';
        nodeElement.style.top = y + 'px';
      }
    }
    
    // Add a new node
    function addNode(x, y, text) {
      const id = idCounter++;
      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = id;
      node.style.left = x + 'px';
      node.style.top = y + 'px';
      
      const content = document.createElement('div');
      content.className = 'node-content';
      content.textContent = text;
      
      node.appendChild(content);
      world.appendChild(node);
      
      nodes[id] = { id, x, y, text, color: '#333' };
      
      setupNodeEventListeners(node);
      selectNode(id);
      
      return id;
    }
    
    // Select a node
    function selectNode(nodeId) {
      clearSelection();
      
      const node = document.querySelector(`.node[data-id="${nodeId}"]`);
      if (node) {
        node.classList.add('selected');
        selectedNode = nodeId;
      }
    }
    
    // Clear selection
    function clearSelection() {
      document.querySelectorAll('.node.selected').forEach(node => {
        node.classList.remove('selected');
      });
      selectedNode = null;
    }
    
    // Delete selected node
    function deleteSelected() {
      if (!selectedNode) return;
      
      // Remove node from DOM
      const nodeElement = document.querySelector(`.node[data-id="${selectedNode}"]`);
      if (nodeElement) {
        nodeElement.remove();
      }
      
      // Remove node from data
      delete nodes[selectedNode];
      
      // Remove any edges connected to this node
      edges = edges.filter(edge => edge.from !== selectedNode && edge.to !== selectedNode);
      
      // Redraw edges
      redrawEdges();
      
      // Clear selection
      clearSelection();
    }
    
    // Redraw all edges
    function redrawEdges() {
      edgesSVG.innerHTML = '';
      
      edges.forEach(edge => {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];
        
        if (fromNode && toNode) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('class', 'connection');
          line.setAttribute('x1', fromNode.x + 65);
          line.setAttribute('y1', fromNode.y + 20);
          line.setAttribute('x2', toNode.x + 65);
          line.setAttribute('y2', toNode.y + 20);
          
          // Highlight if connected to selected node
          if (selectedNode && (edge.from === selectedNode || edge.to === selectedNode)) {
            line.classList.add('highlight');
          }
          
          edgesSVG.appendChild(line);
        }
      });
    }
    
    // Show edit panel for a node
    function showEditPanel(node) {
      const editPanel = document.getElementById('edit-panel');
      const overlay = document.getElementById('overlay');
      const textarea = document.getElementById('edit-textarea');
      
      textarea.value = node.text;
      editPanel.style.display = 'block';
      overlay.style.display = 'block';
      
      // Focus and select text
      setTimeout(() => {
        textarea.focus();
        textarea.select();
      }, 10);
    }
    
    // Close edit panel
    function closeEditPanel() {
      document.getElementById('edit-panel').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
      editMode = false;
      document.getElementById('editBtn').classList.remove('active');
    }
    
    // Save edit panel changes
    function saveEditPanel() {
      if (!selectedNode) return;
      
      const textarea = document.getElementById('edit-textarea');
      const newText = textarea.value.trim();
      
      if (newText) {
        nodes[selectedNode].text = newText;
        
        const nodeElement = document.querySelector(`.node[data-id="${selectedNode}"] .node-content`);
        if (nodeElement) {
          nodeElement.textContent = newText;
        }
      }
      
      closeEditPanel();
    }
    
    // Show color menu
    function showColorMenu(e) {
      if (!selectedNode) {
        alert('Please select a node first');
        return;
      }
      
      hideContextMenu(); // Hide any existing context menu
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      
      const colorPicker = document.createElement('div');
      colorPicker.className = 'color-picker';
      
      const colors = [
        '#2ecc71', '#3498db', '#9b59b6', '#e74c3c', '#f1c40f',
        '#1abc9c', '#34495e', '#e67e22', '#7f8c8d', '#ff6b81'
      ];
      
      colors.forEach(color => {
        const colorOption = document.createElement('div');
        colorOption.className = 'color-option';
        colorOption.style.backgroundColor = color;
        colorOption.onclick = () => {
          changeNodeColor(selectedNode, color);
          menu.remove();
        };
        colorPicker.appendChild(colorOption);
      });
      
      menu.appendChild(colorPicker);
      document.body.appendChild(menu);
      
      // Close menu when clicking elsewhere
      setTimeout(() => {
        document.addEventListener('click', function closeMenu() {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        });
      }, 10);
    }
    
    // Change node color
    function changeNodeColor(nodeId, color) {
      nodes[nodeId].color = color;
      
      const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
      if (nodeElement) {
        nodeElement.style.backgroundColor = color;
      }
      
      saveToFirebase(); // Auto-save after color change
    }
    
    // Handle context menu
    function handleContextMenu(e) {
      e.preventDefault();
      
      const node = e.target.closest('.node');
      if (node) {
        const nodeId = node.dataset.id;
        selectNode(nodeId);
        showContextMenu(e, nodeId);
      } else {
        showStageContextMenu(e);
      }
    }
    
    // Show context menu for a node
    function showContextMenu(e, nodeId) {
      hideContextMenu(); // Hide any existing context menu
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      
      const menuItems = [
        { text: 'Edit', action: () => showEditPanel(nodes[nodeId]) },
        { text: 'Change Color', action: () => showColorMenu(e) },
        { text: 'Delete', action: () => { deleteSelected(); saveToFirebase(); } },
        { text: 'Add Child Node', action: () => {
          const node = nodes[nodeId];
          const childId = addNode(node.x + 200, node.y, 'Child Node');
          edges.push({ from: nodeId, to: childId });
          redrawEdges();
          saveToFirebase();
        }}
      ];
      
      menuItems.forEach(item => {
        const menuItem = document.createElement('div');
        menuItem.className = 'context-menu-item';
        menuItem.textContent = item.text;
        menuItem.onclick = () => {
          item.action();
          menu.remove();
        };
        menu.appendChild(menuItem);
      });
      
      document.body.appendChild(menu);
      
      // Close menu when clicking elsewhere
      setTimeout(() => {
        document.addEventListener('click', function closeMenu() {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        });
      }, 10);
    }
    
    // Show context menu for the stage
    function showStageContextMenu(e) {
      hideContextMenu(); // Hide any existing context menu
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      
      const menuItem = document.createElement('div');
      menuItem.className = 'context-menu-item';
      menuItem.textContent = 'Add Node Here';
      
      // Calculate position considering scroll and zoom
      const rect = world.getBoundingClientRect();
      const x = (e.clientX - rect.left) / scale;
      const y = (e.clientY - rect.top) / scale;
      
      menuItem.onclick = () => {
        addNode(x, y, 'New Node');
        saveToFirebase();
        menu.remove();
      };
      
      menu.appendChild(menuItem);
      document.body.appendChild(menu);
      
      // Close menu when clicking elsewhere
      setTimeout(() => {
        document.addEventListener('click', function closeMenu() {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        });
      }, 10);
    }
    
    // Hide context menu
    function hideContextMenu() {
      document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
    }
    
    // Handle wheel event for zooming
    function handleWheel(e) {
      e.preventDefault();
      
      // Determine zoom direction
      const delta = e.deltaY < 0 ? 0.1 : -0.1;
      adjustZoom(delta, e.clientX, e.clientY);
    }
    
    // Adjust zoom level
    function adjustZoom(delta, centerX, centerY) {
      // Store current scroll position
      const scrollLeft = world.scrollLeft;
      const scrollTop = world.scrollTop;
      
      // Calculate mouse position relative to world
      let mouseX = 0, mouseY = 0;
      
      if (centerX !== undefined && centerY !== undefined) {
        const rect = world.getBoundingClientRect();
        mouseX = (centerX - rect.left + scrollLeft) / scale;
        mouseY = (centerY - rect.top + scrollTop) / scale;
      }
      
      // Update scale
      scale = Math.max(0.1, Math.min(5, scale + delta));
      world.style.transform = `scale(${scale})`;
      
      // Adjust scroll position to zoom toward mouse position
      if (centerX !== undefined && centerY !== undefined) {
        world.scrollLeft = mouseX * scale - (centerX - world.getBoundingClientRect().left);
        world.scrollTop = mouseY * scale - (centerY - world.getBoundingClientRect().top);
      }
      
      updateZoomDisplay();
    }
    
    // Update zoom display
    function updateZoomDisplay() {
      document.getElementById('zoom-display').textContent = Math.round(scale * 100) + '%';
    }
    
    // Start panning
    function startPan(e) {
      if (e.button !== 0) return; // Only left click
      if (e.target.closest('.node')) return; // Don't pan if clicking on a node
      
      panning = true;
      startX = e.clientX;
      startY = e.clientY;
      lastX = world.scrollLeft;
      lastY = world.scrollTop;
    }
    
    // Handle panning
    function handlePan(e) {
      if (!panning) return;
      
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      world.scrollLeft = lastX - dx;
      world.scrollTop = lastY - dy;
    }
    
    // Stop panning
    function stopPan() {
      panning = false;
    }
    
    // Reset view
    function resetView() {
      scale = 1;
      world.style.transform = `scale(${scale})`;
      world.scrollLeft = 500;
      world.scrollTop = 500;
      updateZoomDisplay();
    }
    
    // Apply layout
    function applyLayout(type) {
      const nodeIds = Object.keys(nodes);
      if (nodeIds.length === 0) return;
      
      const rootId = nodeIds[0];
      const centerX = 500;
      const centerY = 500;
      
      if (type === 'horizontal') {
        // Simple horizontal layout
        let x = centerX;
        nodeIds.forEach(id => {
          nodes[id].x = x;
          nodes[id].y = centerY;
          x += 200;
          
          const nodeElement = document.querySelector(`.node[data-id="${id}"]`);
          if (nodeElement) {
            nodeElement.style.left = nodes[id].x + 'px';
            nodeElement.style.top = nodes[id].y + 'px';
          }
        });
      } else if (type === 'vertical') {
        // Simple vertical layout
        let y = centerY;
        nodeIds.forEach(id => {
          nodes[id].x = centerX;
          nodes[id].y = y;
          y += 100;
          
          const nodeElement = document.querySelector(`.node[data-id="${id}"]`);
          if (nodeElement) {
            nodeElement.style.left = nodes[id].x + 'px';
            nodeElement.style.top = nodes[id].y + 'px';
          }
        });
      } else if (type === 'radial') {
        // Simple radial layout
        const angleStep = (2 * Math.PI) / nodeIds.length;
        const radius = 300;
        
        nodeIds.forEach((id, i) => {
          const angle = i * angleStep;
          nodes[id].x = centerX + radius * Math.cos(angle);
          nodes[id].y = centerY + radius * Math.sin(angle);
          
          const nodeElement = document.querySelector(`.node[data-id="${id}"]`);
          if (nodeElement) {
            nodeElement.style.left = nodes[id].x + 'px';
            nodeElement.style.top = nodes[id].y + 'px';
          }
        });
      }
      
      redrawEdges();
    }
    
    // Search nodes
    function searchNodes(query) {
      if (!query) {
        // Reset all nodes
        document.querySelectorAll('.node').forEach(node => {
          node.style.opacity = '1';
          node.style.border = '2px solid #666';
        });
        return;
      }
      
      const lowercaseQuery = query.toLowerCase();
      let foundAny = false;
      
      document.querySelectorAll('.node').forEach(node => {
        const text = node.textContent.toLowerCase();
        if (text.includes(lowercaseQuery)) {
          node.style.opacity = '1';
          node.style.border = '2px solid #0ff';
          foundAny = true;
        } else {
          node.style.opacity = '0.3';
          node.style.border = '2px solid #666';
        }
      });
      
      if (!foundAny) {
        // If no matches, show a message
        console.log('No nodes found matching:', query);
      }
    }
    
    // Export data
    function exportData() {
      const data = {
        nodes: Object.values(nodes),
        edges: edges,
        idCounter: idCounter
      };
      
      const dataStr = JSON.stringify(data, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
      
      const exportFileDefaultName = 'mindmap.json';
      
      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileDefaultName);
      linkElement.click();
    }
    
    // Create import input
    function createImportInput() {
      const input = document.createElement('input');
      input.type = 'file';
      input.id = 'importInput';
      input.accept = '.json';
      input.style.display = 'none';
      input.onchange = handleImport;
      
      document.body.appendChild(input);
      input.click();
    }
    
    // Handle import
    function handleImport(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          loadData(data);
          saveToFirebase(); // Save imported data to cloud
        } catch (error) {
          alert('Error importing file: ' + error.message);
        }
      };
      reader.readAsText(file);
      
      // Clean up
      e.target.remove();
    }
    
    // Initialize the app
    init();
  </script>
</body>
</html>