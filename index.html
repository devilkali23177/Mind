<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Mind Map with Touch Support</title>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #111; 
      color: #fff; 
      touch-action: none; /* Prevent browser handling of touch gestures */
    }
    #toolbar { 
      padding: 8px; 
      background: #222; 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      z-index: 10; 
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    #toolbar button, #toolbar select, #toolbar input { 
      padding: 10px 14px; /* Larger for touch */
      background: #444; 
      color: white;
      border: 1px solid #666;
      border-radius: 6px; /* Slightly larger radius */
      cursor: pointer;
      font-size: 14px; /* Slightly larger text */
      min-height: 20px; /* Minimum touch target size */
    }
    #toolbar button:hover, #toolbar select:hover {
      background: #555;
    }
    #toolbar button.active {
      background: #2a6b9b;
    }
    #toolbar input {
      background: #333;
      width: 100px;
      min-height: 20px;
    }
    #toolbar .separator {
      width: 1px;
      background: #444;
      margin: 0 8px;
      height: 24px;
    }
    #stage { 
      position: absolute; 
      top: 50px; /* Increased for larger toolbar */ 
      left: 0; 
      right: 0; 
      bottom: 0; 
      overflow: auto; 
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }
    #world { 
      position: relative; 
      width: 5000px; 
      height: 5000px; 
      transform-origin: 0 0;
    }
    .node { 
      position: absolute; 
      min-width: 130px; /* Slightly larger for touch */
      max-width: 250px;
      padding: 12px 16px; /* More padding for touch */
      background: #333; 
      border: 2px solid #666; /* Thicker border for visibility */
      border-radius: 10px; /* Slightly larger radius */
      cursor: grab; 
      user-select: none; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      overflow: hidden;
      text-overflow: ellipsis;
      transition: transform 0.1s ease;
      font-size: 16px; /* Slightly larger text */
      touch-action: none; /* Prevent browser handling of touch on nodes */
    }
    .node:hover {
      transform: scale(1.02);
    }
    .node.selected { 
      border-color: #0ff; 
      box-shadow: 0 0 10px rgba(0,255,255,0.5);
    }
    .node.dragging {
      cursor: grabbing;
      opacity: 0.9;
    }
    .node-content {
      min-height: 24px; /* Slightly larger */
      word-wrap: break-word;
    }
    svg { 
      position: absolute; 
      inset: 0; 
      pointer-events: none; 
    }
    line.connection {
      stroke: #0ff;
      stroke-width: 2;
    }
    line.connection.highlight {
      stroke: #ff0;
      stroke-width: 3;
    }
    #zoom-display {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px; /* Slightly larger */
      border-radius: 4px;
      font-size: 14px;
      z-index: 5;
    }
    .context-menu {
      position: fixed;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      z-index: 100;
      min-width: 150px; /* Minimum width for touch */
    }
    .context-menu-item {
      padding: 12px 16px; /* Larger for touch */
      cursor: pointer;
      font-size: 16px; /* Slightly larger text */
    }
    .context-menu-item:hover {
      background: #444;
    }
    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 6px; /* Slightly larger gap */
      padding: 10px; /* More padding */
      width: 140px; /* Slightly wider */
    }
    .color-option {
      width: 28px; /* Larger color options */
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #555; /* Thicker border */
    }
    .node-edit-input {
      position: absolute;
      background: #222;
      border: 2px solid #0ff;
      border-radius: 6px;
      padding: 8px; /* More padding */
      color: white;
      font: inherit;
      z-index: 20;
      min-width: 120px; /* Slightly larger */
      resize: both;
      overflow: auto;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      font-size: 16px; /* Slightly larger text */
    }
    #edit-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      border: 2px solid #0ff;
      border-radius: 8px;
      padding: 20px;
      z-index: 100;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      width: 320px; /* Slightly wider */
      display: none;
    }
    #edit-panel h3 {
      margin-top: 0;
      color: #0ff;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
      font-size: 18px; /* Slightly larger */
    }
    #edit-textarea {
      width: 100%;
      height: 120px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 10px; /* More padding */
      resize: vertical;
      margin-bottom: 15px;
      font-family: inherit;
      font-size: 16px; /* Slightly larger text */
    }
    #edit-panel-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    #edit-panel button {
      padding: 10px 18px; /* Larger buttons */
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px; /* Slightly larger text */
      min-width: 80px; /* Minimum button width */
    }
    #edit-panel-save {
      background: #2a6b9b;
      color: white;
    }
    #edit-panel-cancel {
      background: #555;
      color: white;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 90;
      display: none;
    }
    
    /* Placement mode styles */
    #placement-indicator {
      position: absolute;
      width: 200px;
      height: 200px;
      border: 2px dashed #0ff;
      border-radius: 10px;
      pointer-events: none;
      z-index: 5;
      display: none;
      background-color: rgba(0, 255, 255, 0.1);
    }
    #placement-preview {
      position: absolute;
      pointer-events: none;
      z-index: 4;
      opacity: 0.7;
      display: none;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      #toolbar {
        padding: 6px;
        gap: 4px;
        overflow-x: auto; /* Allow horizontal scrolling on mobile */
        white-space: nowrap;
        height: 44px; /* Fixed height */
      }
      #toolbar button, #toolbar select, #toolbar input {
        padding: 8px 10px;
        font-size: 13px;
      }
      #stage {
        top: 46px; /* Adjusted for smaller toolbar */
      }
      .node {
        min-width: 110px;
        padding: 10px 12px;
        font-size: 15px;
      }
      #zoom-display {
        bottom: 5px;
        right: 5px;
        font-size: 12px;
        padding: 4px 8px;
      }
    }
    
    /* Prevent text selection on UI elements */
    .node, #toolbar button, .context-menu-item {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* Long press detection style */
    .long-press {
      animation: pulse 0.8s infinite alternate;
    }
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="addBtn">Add Node</button>
    <button id="connectBtn">Connect Nodes</button>
    <button id="editBtn">Edit Node</button>
    <button id="deleteBtn">Delete</button>
    <div class="separator"></div>
    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
    <button id="resetViewBtn">Reset View</button>
    <div class="separator"></div>
    <button id="colorBtn">Color</button>
    <button id="exportBtn">Export</button>
    <button id="importBtn">Import</button>
    <button id="placementBtn">Placement Mode</button>
    <div class="separator"></div>
    <select id="layoutBtn">
      <option value="">Layout</option>
      <option value="horizontal">Horizontal</option>
      <option value="vertical">Vertical</option>
      <option value="radial">Radial</option>
    </select>
    <input type="text" id="searchInput" placeholder="Search nodes...">
  </div>
  <div id="stage">
    <div id="world">
      <svg id="edges" width="5000" height="5000"></svg>
      <div id="placement-indicator"></div>
      <div id="placement-preview"></div>
    </div>
  </div>
  <div id="zoom-display">100%</div>
  
  <!-- Edit Panel -->
  <div id="overlay"></div>
  <div id="edit-panel">
    <h3>Edit Node Content</h3>
    <textarea id="edit-textarea"></textarea>
    <div id="edit-panel-buttons">
      <button id="edit-panel-cancel">Cancel</button>
      <button id="edit-panel-save">Save</button>
    </div>
  </div>
  
  <script>
    // Main application variables
    const world = document.getElementById('world');
    const edgesSVG = document.getElementById('edges');
    let nodes = {};
    let edges = [];
    let idCounter = 1;
    let connectMode = false;
    let editMode = false;
    let connectFrom = null;
    let selectedNode = null;
    let scale = 1;
    let panning = false;
    let startX, startY;
    let initialPinchDistance = null;
    let lastX = 0, lastY = 0;
    let activeEditInput = null;
    let longPressTimer = null;
    let isLongPress = false;
    
    // New variables for fixing node dragging
    let isDraggingNode = false;
    let initialTouchPositions = null;
    
    // Placement mode variables
    let placementMode = false;
    let importData = null;
    let placementX = 0;
    let placementY = 0;
    const placementIndicator = document.getElementById('placement-indicator');
    const placementPreview = document.getElementById('placement-preview');
    
    // Initialize the application
    function init() {
      // Add event listeners
      setupEventListeners();
      
      // Add initial node
      addNode(500, 500, 'Main Topic');
      
      // Update zoom display
      updateZoomDisplay();
    }
    
    // Set up all event listeners
    function setupEventListeners() {
      // Toolbar buttons
      document.getElementById('addBtn').onclick = () => {
        const x = 500 + Math.random() * 400;
        const y = 500 + Math.random() * 400;
        addNode(x, y, 'New Node');
      };
      
      document.getElementById('connectBtn').onclick = () => {
        connectMode = !connectMode;
        editMode = false;
        placementMode = false;
        document.getElementById('connectBtn').classList.toggle('active', connectMode);
        document.getElementById('editBtn').classList.remove('active');
        document.getElementById('placementBtn').classList.remove('active');
        connectFrom = null;
        clearSelection();
        hidePlacementUI();
      };
      
      document.getElementById('editBtn').onclick = () => {
        editMode = !editMode;
        connectMode = false;
        placementMode = false;
        document.getElementById('editBtn').classList.toggle('active', editMode);
        document.getElementById('connectBtn').classList.remove('active');
        document.getElementById('placementBtn').classList.remove('active');
        hidePlacementUI();
      };
      
      document.getElementById('deleteBtn').onclick = deleteSelected;
      
      document.getElementById('zoomInBtn').onclick = () => adjustZoom(0.1);
      document.getElementById('zoomOutBtn').onclick = () => adjustZoom(-0.1);
      document.getElementById('resetViewBtn').onclick = resetView;
      
      document.getElementById('colorBtn').onclick = showColorMenu;
      document.getElementById('exportBtn').onclick = exportData;
      document.getElementById('importBtn').onclick = () => document.getElementById('importInput')?.click() || createImportInput();
      
      // Placement mode button
      document.getElementById('placementBtn').onclick = () => {
        placementMode = !placementMode;
        document.getElementById('placementBtn').classList.toggle('active', placementMode);
        
        if (placementMode && importData) {
          showPlacementUI();
        } else {
          hidePlacementUI();
        }
      };
      
      document.getElementById('layoutBtn').onchange = (e) => {
        if (e.target.value) applyLayout(e.target.value);
      };
      
      document.getElementById('searchInput').oninput = (e) => {
        searchNodes(e.target.value);
      };
      
      // Edit panel buttons
      document.getElementById('edit-panel-save').onclick = saveEditPanel;
      document.getElementById('edit-panel-cancel').onclick = closeEditPanel;
      document.getElementById('overlay').onclick = closeEditPanel;
      
      // Panning and zooming
      world.addEventListener('wheel', handleWheel, { passive: false });
      world.addEventListener('mousedown', startPan);
      document.addEventListener('mousemove', handlePan);
      document.addEventListener('mouseup', stopPan);
      
      // Placement mode mouse events
      world.addEventListener('mousemove', handlePlacementMove);
      world.addEventListener('click', handlePlacementClick);
      
      // Touch events for mobile
      setupTouchEvents();
      
      // Context menu
      world.addEventListener('contextmenu', handleContextMenu);
      
      // Click outside to clear selection
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.node') && !e.target.closest('.context-menu') && 
            !e.target.closest('.node-edit-input') && !e.target.closest('#edit-panel')) {
          clearSelection();
          hideContextMenu();
        }
      });
      
      // Double click to edit
      world.addEventListener('dblclick', (e) => {
        const node = e.target.closest('.node');
        if (node) {
          const nodeId = node.dataset.id;
          selectNode(nodeId);
          showEditPanel(nodes[nodeId]);
        }
      });
    }
    
    // Enhanced touch event setup
    function setupTouchEvents() {
      // Single touch for panning and node interaction
      world.addEventListener('touchstart', handleTouchStart, { passive: false });
      world.addEventListener('touchmove', handleTouchMove, { passive: false });
      world.addEventListener('touchend', handleTouchEnd);
      world.addEventListener('touchcancel', handleTouchEnd);
      
      // Prevent elastic scrolling on iOS
      document.body.addEventListener('touchmove', function(e) {
        if (e.target.closest('#stage') || e.target.closest('#world')) {
          e.preventDefault();
        }
      }, { passive: false });
      
      // Add long press support for context menu
      world.addEventListener('touchstart', handleLongPressStart, { passive: true });
      world.addEventListener('touchend', handleLongPressEnd);
      world.addEventListener('touchcancel', handleLongPressEnd);
    }
    
    // Long press handling for touch devices
    function handleLongPressStart(e) {
      if (e.touches.length !== 1) return;
      
      const node = e.target.closest('.node');
      if (node) {
        isLongPress = false;
        longPressTimer = setTimeout(() => {
          isLongPress = true;
          const touch = e.touches[0];
          const nodeId = node.dataset.id;
          selectedNode = nodeId;
          node.classList.add('long-press');
          showNodeContextMenu(touch.clientX, touch.clientY);
        }, 500); // 500ms for long press
      }
    }
    
    function handleLongPressEnd(e) {
      clearTimeout(longPressTimer);
      document.querySelectorAll('.node').forEach(n => n.classList.remove('long-press'));
      
      // If it was a long press, prevent the default click behavior
      if (isLongPress) {
        e.preventDefault();
        isLongPress = false;
      }
    }
    
    // Enhanced touch event handlers
    function handleTouchStart(e) {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        startX = touch.clientX - lastX;
        startY = touch.clientY - lastY;
        
        // Check if touching a node
        const node = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.node');
        if (node) {
          const nodeId = node.dataset.id;
          
          if (connectMode) {
            if (!connectFrom) {
              connectFrom = nodeId;
              node.classList.add('selected');
            } else if (connectFrom !== nodeId) {
              addEdge(connectFrom, nodeId);
              document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
              connectFrom = null;
            }
            e.preventDefault();
          } else {
            e.preventDefault();
            selectNode(nodeId);
            // Store initial positions for node dragging
            initialTouchPositions = {
              nodeX: nodes[nodeId].x,
              nodeY: nodes[nodeId].y,
              clientX: touch.clientX,
              clientY: touch.clientY
            };
            isDraggingNode = true;
          }
        } else {
          // Not touching a node, prepare for panning
          isDraggingNode = false;
        }
      } else if (e.touches.length === 2) {
        // Two touches - prepare for pinch to zoom
        isDraggingNode = false;
        initialPinchDistance = getDistance(
          e.touches[0].clientX, e.touches[0].clientY,
          e.touches[1].clientX, e.touches[1].clientY
        );
        e.preventDefault();
      }
    }
    
    function handleTouchMove(e) {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        
        if (isDraggingNode && selectedNode) {
          // Dragging a node
          const dx = (touch.clientX - initialTouchPositions.clientX) / scale;
          const dy = (touch.clientY - initialTouchPositions.clientY) / scale;
          
          nodes[selectedNode].x = initialTouchPositions.nodeX + dx;
          nodes[selectedNode].y = initialTouchPositions.nodeY + dy;
          
          const nodeEl = world.querySelector(`[data-id="${selectedNode}"]`);
          if (nodeEl) {
            nodeEl.style.left = nodes[selectedNode].x + 'px';
            nodeEl.style.top = nodes[selectedNode].y + 'px';
          }
          
          refreshEdgesFor(selectedNode);
          e.preventDefault();
        } else {
          // Panning the canvas
          lastX = touch.clientX - startX;
          lastY = touch.clientY - startY;
          world.style.left = lastX + 'px';
          world.style.top = lastY + 'px';
          e.preventDefault();
        }
      } else if (e.touches.length === 2) {
        // Two touches - pinch to zoom
        isDraggingNode = false;
        const currentDistance = getDistance(
          e.touches[0].clientX, e.touches[0].clientY,
          e.touches[1].clientX, e.touches[1].clientY
        );
        
        if (initialPinchDistance !== null) {
          const zoomFactor = currentDistance / initialPinchDistance;
          scale = Math.max(0.1, Math.min(5, scale * zoomFactor));
          world.style.transform = `scale(${scale})`;
          initialPinchDistance = currentDistance;
          updateZoomDisplay();
        }
        e.preventDefault();
      }
    }
    
    function handleTouchEnd(e) {
      if (e.touches.length === 0) {
        initialPinchDistance = null;
        isDraggingNode = false;
        
        // Handle node selection on tap (not long press)
        if (!isLongPress && e.changedTouches.length === 1 && !initialTouchPositions) {
          const touch = e.changedTouches[0];
          const node = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.node');
          
          if (node) {
            const nodeId = node.dataset.id;
            
            if (editMode) {
              showEditPanel(nodes[nodeId]);
            } else if (!connectMode) {
              selectNode(nodeId);
            }
          }
        }
        isLongPress = false;
        initialTouchPositions = null;
      }
    }
    
    // Placement mode functions
    function handlePlacementMove(e) {
      if (!placementMode || !importData) return;
      
      const rect = world.getBoundingClientRect();
      placementX = (e.clientX - rect.left - lastX) / scale;
      placementY = (e.clientY - rect.top - lastY) / scale;
      
      // Update placement indicator position
      placementIndicator.style.left = (placementX - 100) + 'px';
      placementIndicator.style.top = (placementY - 100) + 'px';
      placementIndicator.style.display = 'block';
      
      // Update preview if we have import data
      updatePlacementPreview();
    }
    
    function handlePlacementClick(e) {
      if (!placementMode || !importData) return;
      
      // Place the imported mind map at the selected location
      if (confirm("Do you want to merge this mind map with your current one? Click OK to merge, Cancel to replace.")) {
        mergeData(importData, placementX, placementY);
      } else {
        loadData(importData, placementX, placementY);
      }
      
      // Reset placement mode
      placementMode = false;
      importData = null;
      document.getElementById('placementBtn').classList.remove('active');
      hidePlacementUI();
    }
    
    function showPlacementUI() {
      placementIndicator.style.display = 'block';
      placementPreview.style.display = 'block';
    }
    
    function hidePlacementUI() {
      placementIndicator.style.display = 'none';
      placementPreview.style.display = 'none';
    }
    
    function updatePlacementPreview() {
      if (!importData || !importData.nodes || importData.nodes.length === 0) return;
      
      // Calculate bounds of the imported mind map
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      importData.nodes.forEach(node => {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x);
        maxY = Math.max(maxY, node.y);
      });
      
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      
      // Create preview HTML
      let previewHTML = '';
      importData.nodes.forEach(node => {
        const relativeX = node.x - centerX;
        const relativeY = node.y - centerY;
        previewHTML += `<div class="node" style="left:${placementX + relativeX}px;top:${placementY + relativeY}px;background-color:${node.color || '#333'};opacity:0.5;">
          <div class="node-content">${node.title}</div>
        </div>`;
      });
      
      placementPreview.innerHTML = previewHTML;
    }
    
    // Node management functions
    function addNode(x, y, title = 'New Node') {
      const id = 'n' + idCounter++;
      const node = { 
        id, 
        x, 
        y, 
        title,
        color: '#333',
        width: 120,
        height: 40
      };
      nodes[id] = node;

      const el = document.createElement('div');
      el.className = 'node';
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.backgroundColor = node.color;
      el.dataset.id = id;
      
      const content = document.createElement('div');
      content.className = 'node-content';
      content.textContent = title;
      el.appendChild(content);
      
      world.appendChild(el);

      setupNodeInteractions(el, node);
      return node;
    }
    
    function setupNodeInteractions(el, node) {
      let dragging = false, sx = 0, sy = 0, ox = 0, oy = 0;
      
      el.addEventListener('mousedown', e => {
        if (e.button !== 0) return; // Only left click
        
        if (editMode) {
          e.stopPropagation();
          showEditPanel(node);
          return;
        }
        
        dragging = true;
        sx = e.clientX;
        sy = e.clientY;
        ox = node.x;
        oy = node.y;
        el.classList.add('dragging');
        
        selectNode(node.id);
        e.stopPropagation();
        
        // Prevent panning when dragging a node
        e.preventDefault();
      });
      
      window.addEventListener('mousemove', e => {
        if (!dragging) return;
        const dx = (e.clientX - sx) / scale;
        const dy = (e.clientY - sy) / scale;
        node.x = ox + dx;
        node.y = oy + dy;
        el.style.left = node.x + 'px';
        el.style.top = node.y + 'px';
        refreshEdgesFor(node.id);
        
        // Prevent panning when dragging a node
        e.preventDefault();
      });
      
      window.addEventListener('mouseup', () => {
        if (dragging) {
          dragging = false;
          el.classList.remove('dragging');
        }
      });
      
      el.addEventListener('click', e => {
        if (connectMode) {
          if (!connectFrom) {
            connectFrom = node.id;
            el.classList.add('selected');
          } else if (connectFrom !== node.id) {
            addEdge(connectFrom, node.id);
            document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
            connectFrom = null;
          }
          e.stopPropagation();
        } else if (!editMode) {
          selectNode(node.id);
          e.stopPropagation();
        }
      });
    }
    
    function selectNode(nodeId) {
      clearSelection();
      selectedNode = nodeId;
      const el = world.querySelector(`[data-id="${nodeId}"]`);
      if (el) el.classList.add('selected');
    }
    
    function clearSelection() {
      selectedNode = null;
      document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
    }
    
    function deleteSelected() {
      if (!selectedNode) return;
      
      // Remove node
      const el = world.querySelector(`[data-id="${selectedNode}"]`);
      if (el) el.remove();
      
      // Remove connected edges
      edges = edges.filter(edge => {
        if (edge.from === selectedNode || edge.to === selectedNode) {
          return false;
        }
        return true;
      });
      
      // Remove from nodes object
      delete nodes[selectedNode];
      
      // Refresh edges display
      refreshAllEdges();
      
      clearSelection();
    }
    
    // Edit panel functions
    function showEditPanel(node) {
      if (!node) return;
      
      const editPanel = document.getElementById('edit-panel');
      const editTextarea = document.getElementById('edit-textarea');
      const overlay = document.getElementById('overlay');
      
      editTextarea.value = node.title;
      editPanel.style.display = 'block';
      overlay.style.display = 'block';
      
      // Store reference to the node being edited
      editPanel.dataset.editingNode = node.id;
      
      // Focus the textarea
      setTimeout(() => {
        editTextarea.focus();
        // Move cursor to end of text
        editTextarea.setSelectionRange(editTextarea.value.length, editTextarea.value.length);
      }, 100);
    }
    
    function closeEditPanel() {
      const editPanel = document.getElementById('edit-panel');
      const overlay = document.getElementById('overlay');
      
      editPanel.style.display = 'none';
      overlay.style.display = 'none';
      delete editPanel.dataset.editingNode;
    }
    
    function saveEditPanel() {
      const editPanel = document.getElementById('edit-panel');
      const editTextarea = document.getElementById('edit-textarea');
      const nodeId = editPanel.dataset.editingNode;
      
      if (nodeId && nodes[nodeId]) {
        nodes[nodeId].title = editTextarea.value;
        const el = world.querySelector(`[data-id="${nodeId}"]`);
        if (el) {
          const contentEl = el.querySelector('.node-content');
          if (contentEl) contentEl.textContent = editTextarea.value;
        }
      }
      
      closeEditPanel();
    }
    
    // Edge management functions
    function addEdge(from, to) {
      // Check if edge already exists
      if (edges.some(edge => (edge.from === from && edge.to === to) || (edge.from === to && edge.to === from))) {
        return;
      }
      
      const edge = { from, to };
      edges.push(edge);
      drawEdge(edge);
    }
    
    function nodeCenter(id) {
      const n = nodes[id];
      const el = world.querySelector('[data-id="'+id+'"]');
      return { 
        x: n.x + el.offsetWidth/2, 
        y: n.y + el.offsetHeight/2 
      };
    }
    
    function drawEdge(edge) {
      const a = nodeCenter(edge.from);
      const b = nodeCenter(edge.to);
      
      const path = document.createElementNS('http://www.w3.org/2000/svg','line');
      path.setAttribute('x1', a.x);
      path.setAttribute('y1', a.y);
      path.setAttribute('x2', b.x);
      path.setAttribute('y2', b.y);
      path.setAttribute('stroke', '#0ff');
      path.setAttribute('stroke-width', '2');
      path.classList.add('connection');
      path.dataset.from = edge.from;
      path.dataset.to = edge.to;
      
      edgesSVG.appendChild(path);
    }
    
    function refreshEdgesFor(nodeId) {
      refreshAllEdges();
    }
    
    function refreshAllEdges() {
      edgesSVG.innerHTML = '';
      edges.forEach(drawEdge);
    }
    
    // View manipulation functions
    function adjustZoom(amount) {
      scale += amount;
      scale = Math.max(0.1, Math.min(5, scale)); // Limit zoom range
      world.style.transform = `scale(${scale})`;
      updateZoomDisplay();
    }
    
    function resetView() {
      scale = 1;
      world.style.transform = `scale(${scale})`;
      world.style.left = '0px';
      world.style.top = '0px';
      lastX = 0;
      lastY = 0;
      updateZoomDisplay();
    }
    
    function updateZoomDisplay() {
      document.getElementById('zoom-display').textContent = Math.round(scale * 100) + '%';
    }
    
    function startPan(e) {
      if (e.button !== 0 || e.target.closest('.node') || e.target.closest('.node-edit-input')) return;
      panning = true;
      startX = e.clientX - lastX;
      startY = e.clientY - lastY;
      world.style.cursor = 'grabbing';
    }
    
    function handlePan(e) {
      if (!panning) return;
      e.preventDefault();
      
      lastX = e.clientX - startX;
      lastY = e.clientY - startY;
      
      world.style.left = lastX + 'px';
      world.style.top = lastY + 'px';
    }
    
    function stopPan() {
      panning = false;
      world.style.cursor = 'default';
    }
    
    function handleWheel(e) {
      e.preventDefault();
      
      if (e.ctrlKey) {
        // Zoom with Ctrl+Wheel
        const delta = e.deltaY < 0 ? 0.1 : -0.1;
        adjustZoom(delta);
      } else {
        // Pan with wheel (normal scrolling)
        world.scrollLeft -= e.deltaX;
        world.scrollTop -= e.deltaY;
      }
    }
    
    function getDistance(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    
    // Context menu
    function handleContextMenu(e) {
      e.preventDefault();
      hideContextMenu();
      
      const node = e.target.closest('.node');
      if (node) {
        selectedNode = node.dataset.id;
        node.classList.add('selected');
        showNodeContextMenu(e.clientX, e.clientY);
      } else {
        showCanvasContextMenu(e.clientX, e.clientY);
      }
    }
    
    function showNodeContextMenu(x, y) {
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      
      const items = [
        { text: 'Edit', action: () => showEditPanel(nodes[selectedNode]) },
        { text: 'Change Color', action: showColorMenu },
        { text: 'Delete', action: deleteSelected }
      ];
      
      items.forEach(item => {
        const menuItem = document.createElement('div');
        menuItem.className = 'context-menu-item';
        menuItem.textContent = item.text;
        menuItem.onclick = item.action;
        menu.appendChild(menuItem);
      });
      
      document.body.appendChild(menu);
    }
    
    function showCanvasContextMenu(x, y) {
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      
      const items = [
        { text: 'Add Node', action: () => addNode(x, y, 'New Node') },
        { text: 'Reset View', action: resetView }
      ];
      
      items.forEach(item => {
        const menuItem = document.createElement('div');
        menuItem.className = 'context-menu-item';
        menuItem.textContent = item.text;
        menuItem.onclick = item.action;
        menu.appendChild(menuItem);
      });
      
      document.body.appendChild(menu);
    }
    
    function hideContextMenu() {
      const menus = document.querySelectorAll('.context-menu');
      menus.forEach(menu => menu.remove());
    }
    
    function showColorMenu() {
      if (!selectedNode) return;
      
      hideContextMenu();
      
      const nodeEl = world.querySelector(`[data-id="${selectedNode}"]`);
      if (!nodeEl) return;
      
      const rect = nodeEl.getBoundingClientRect();
      const menu = document.createElement('div');
      menu.className = 'context-menu color-picker';
      menu.style.left = rect.right + 'px';
      menu.style.top = rect.top + 'px';
      
      const colors = [
        '#333', '#2a6b9b', '#3d8e5e', '#9b6b2a', 
        '#9b2a5e', '#5e2a9b', '#9b8e2a', '#2a9b8e'
      ];
      
      colors.forEach(color => {
        const colorEl = document.createElement('div');
        colorEl.className = 'color-option';
        colorEl.style.backgroundColor = color;
        colorEl.onclick = () => {
          nodes[selectedNode].color = color;
          nodeEl.style.backgroundColor = color;
          hideContextMenu();
        };
        menu.appendChild(colorEl);
      });
      
      document.body.appendChild(menu);
    }
    
    // Import/Export functions
    function exportData() {
      const data = {
        nodes: Object.values(nodes),
        edges: edges
      };
      
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mindmap.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    function createImportInput() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.id = 'importInput';
      input.style.display = 'none';
      input.onchange = handleImport;
      document.body.appendChild(input);
      input.click();
    }
    
    function handleImport(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          importData = data;
          
          // Ask user if they want to place the mind map
          if (confirm("Do you want to place this mind map at a specific location? Click OK to place, Cancel to merge with current view.")) {
            // Enable placement mode
            placementMode = true;
            document.getElementById('placementBtn').classList.add('active');
            showPlacementUI();
          } else {
            // Merge with current view
            if (confirm("Do you want to merge this mind map with your current one? Click OK to merge, Cancel to replace.")) {
              mergeData(data);
            } else {
              loadData(data);
            }
          }
        } catch (error) {
          alert('Error importing file: ' + error.message);
        }
      };
      reader.readAsText(file);
      
      // Clean up
      e.target.remove();
    }
    
    function loadData(data, offsetX = 0, offsetY = 0) {
      // Clear current data
      document.querySelectorAll('.node').forEach(n => n.remove());
      edgesSVG.innerHTML = '';
      
      // Load new data
      nodes = {};
      edges = data.edges || [];
      
      // Find the center of the imported mind map
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      data.nodes.forEach(node => {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x);
        maxY = Math.max(maxY, node.y);
      });
      
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      
      // Add nodes with offset
      data.nodes.forEach(node => {
        const relativeX = node.x - centerX;
        const relativeY = node.y - centerY;
        nodes[node.id] = {
          ...node,
          x: offsetX + relativeX,
          y: offsetY + relativeY
        };
        
        const el = document.createElement('div');
        el.className = 'node';
        el.style.left = (offsetX + relativeX) + 'px';
        el.style.top = (offsetY + relativeY) + 'px';
        el.style.backgroundColor = node.color || '#333';
        el.dataset.id = node.id;
        
        const content = document.createElement('div');
        content.className = 'node-content';
        content.textContent = node.title;
        el.appendChild(content);
        
        world.appendChild(el);
        setupNodeInteractions(el, nodes[node.id]);
      });
      
      // Update idCounter
      const maxId = Math.max(...Object.keys(nodes).map(id => parseInt(id.substring(1))));
      idCounter = maxId + 1;
      
      // Draw edges
      refreshAllEdges();
      
      // Reset view
      resetView();
    }
    
    function mergeData(data, offsetX = 0, offsetY = 0) {
      // Find the center of the imported mind map
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      data.nodes.forEach(node => {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x);
        maxY = Math.max(maxY, node.y);
      });
      
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      
      // Add nodes with offset
      data.nodes.forEach(node => {
        const relativeX = node.x - centerX;
        const relativeY = node.y - centerY;
        const newNode = addNode(offsetX + relativeX, offsetY + relativeY, node.title);
        newNode.color = node.color || '#333';
        
        // Update the node element with the correct color
        const el = world.querySelector(`[data-id="${newNode.id}"]`);
        if (el) {
          el.style.backgroundColor = newNode.color;
        }
        
        // Map old ID to new ID for edge connections
        node.newId = newNode.id;
      });
      
      // Add edges with updated node IDs
      data.edges.forEach(edge => {
        const fromNode = data.nodes.find(n => n.id === edge.from);
        const toNode = data.nodes.find(n => n.id === edge.to);
        
        if (fromNode && toNode && fromNode.newId && toNode.newId) {
          addEdge(fromNode.newId, toNode.newId);
        }
      });
      
      // Refresh edges
      refreshAllEdges();
    }
    
    // Search function
    function searchNodes(query) {
      if (!query) {
        // Reset all nodes to normal
        document.querySelectorAll('.node').forEach(node => {
          node.style.opacity = '1';
          node.style.border = '2px solid #666';
        });
        return;
      }
      
      const lowerQuery = query.toLowerCase();
      let hasMatch = false;
      
      // Search through nodes
      Object.values(nodes).forEach(node => {
        const nodeEl = world.querySelector(`[data-id="${node.id}"]`);
        if (!nodeEl) return;
        
        if (node.title.toLowerCase().includes(lowerQuery)) {
          nodeEl.style.opacity = '1';
          nodeEl.style.border = '2px solid #ff0';
          hasMatch = true;
        } else {
          nodeEl.style.opacity = '0.3';
          nodeEl.style.border = '2px solid #666';
        }
      });
      
      // Highlight edges connected to matching nodes
      document.querySelectorAll('.connection').forEach(conn => {
        const fromId = conn.dataset.from;
        const toId = conn.dataset.to;
        
        const fromNode = nodes[fromId];
        const toNode = nodes[toId];
        
        if (fromNode && toNode && 
            (fromNode.title.toLowerCase().includes(lowerQuery) || 
             toNode.title.toLowerCase().includes(lowerQuery))) {
          conn.classList.add('highlight');
        } else {
          conn.classList.remove('highlight');
        }
      });
      
      // If no matches, show message
      if (!hasMatch) {
        // Could show a "no results" message here
      }
    }
    
    // Layout functions
    function applyLayout(type) {
      if (!selectedNode && Object.keys(nodes).length === 0) return;
      
      const rootId = selectedNode || Object.keys(nodes)[0];
      const rootNode = nodes[rootId];
      
      switch (type) {
        case 'horizontal':
          applyHorizontalLayout(rootId);
          break;
        case 'vertical':
          applyVerticalLayout(rootId);
          break;
        case 'radial':
          applyRadialLayout(rootId);
          break;
      }
      
      // Reset the layout dropdown
      document.getElementById('layoutBtn').value = '';
      
      // Refresh all edges
      refreshAllEdges();
    }
    
    function applyHorizontalLayout(rootId) {
      const root = nodes[rootId];
      const visited = new Set();
      const queue = [{ node: root, x: root.x, y: root.y, level: 0 }];
      visited.add(rootId);
      
      // First pass: calculate required space
      const levelWidths = {};
      const levelCounts = {};
      
      const measureQueue = [{ id: rootId, level: 0 }];
      const measureVisited = new Set([rootId]);
      
      while (measureQueue.length > 0) {
        const current = measureQueue.shift();
        const node = nodes[current.id];
        
        // Count nodes at this level
        levelCounts[current.level] = (levelCounts[current.level] || 0) + 1;
        
        // Find all connected nodes (both from and to edges)
        const connectedNodes = [];
        edges.forEach(edge => {
          if (edge.from === current.id && !measureVisited.has(edge.to)) {
            connectedNodes.push({ id: edge.to, level: current.level + 1 });
          } else if (edge.to === current.id && !measureVisited.has(edge.from)) {
            connectedNodes.push({ id: edge.from, level: current.level + 1 });
          }
        });
        
        // Add to queue
        connectedNodes.forEach(n => {
          measureQueue.push(n);
          measureVisited.add(n.id);
        });
      }
      
      // Calculate level widths
      const maxLevel = Math.max(...Object.keys(levelCounts).map(Number));
      for (let level = 0; level <= maxLevel; level++) {
        levelWidths[level] = (levelCounts[level] || 0) * 200;
      }
      
      // Second pass: position nodes
      while (queue.length > 0) {
        const current = queue.shift();
        const node = current.node;
        
        // Position the node
        node.x = current.x;
        node.y = current.y;
        
        const nodeEl = world.querySelector(`[data-id="${node.id}"]`);
        if (nodeEl) {
          nodeEl.style.left = node.x + 'px';
          nodeEl.style.top = node.y + 'px';
        }
        
        // Find all connected nodes
        const connectedNodes = [];
        edges.forEach(edge => {
          if (edge.from === node.id && !visited.has(edge.to)) {
            connectedNodes.push({ id: edge.to, direction: 'right' });
          } else if (edge.to === node.id && !visited.has(edge.from)) {
            connectedNodes.push({ id: edge.from, direction: 'left' });
          }
        });
        
        // Position connected nodes
        connectedNodes.forEach((n, index) => {
          const connectedNode = nodes[n.id];
          if (!connectedNode) return;
          
          const level = current.level + 1;
          const levelWidth = levelWidths[level] || 200;
          const levelStartX = root.x - levelWidth / 2;
          
          // Calculate position based on level and index
          const x = levelStartX + (index * 200) + 100;
          const y = current.y;
          
          queue.push({ node: connectedNode, x, y, level });
          visited.add(n.id);
        });
      }
    }
    
    function applyVerticalLayout(rootId) {
      const root = nodes[rootId];
      const visited = new Set();
      const queue = [{ node: root, x: root.x, y: root.y, level: 0 }];
      visited.add(rootId);
      
      // First pass: calculate required space
      const levelHeights = {};
      const levelCounts = {};
      
      const measureQueue = [{ id: rootId, level: 0 }];
      const measureVisited = new Set([rootId]);
      
      while (measureQueue.length > 0) {
        const current = measureQueue.shift();
        const node = nodes[current.id];
        
        // Count nodes at this level
        levelCounts[current.level] = (levelCounts[current.level] || 0) + 1;
        
        // Find all connected nodes
        const connectedNodes = [];
        edges.forEach(edge => {
          if (edge.from === current.id && !measureVisited.has(edge.to)) {
            connectedNodes.push({ id: edge.to, level: current.level + 1 });
          } else if (edge.to === current.id && !measureVisited.has(edge.from)) {
            connectedNodes.push({ id: edge.from, level: current.level + 1 });
          }
        });
        
        // Add to queue
        connectedNodes.forEach(n => {
          measureQueue.push(n);
          measureVisited.add(n.id);
        });
      }
      
      // Calculate level heights
      const maxLevel = Math.max(...Object.keys(levelCounts).map(Number));
      for (let level = 0; level <= maxLevel; level++) {
        levelHeights[level] = (levelCounts[level] || 0) * 100;
      }
      
      // Second pass: position nodes
      while (queue.length > 0) {
        const current = queue.shift();
        const node = current.node;
        
        // Position the node
        node.x = current.x;
        node.y = current.y;
        
        const nodeEl = world.querySelector(`[data-id="${node.id}"]`);
        if (nodeEl) {
          nodeEl.style.left = node.x + 'px';
          nodeEl.style.top = node.y + 'px';
        }
        
        // Find all connected nodes
        const connectedNodes = [];
        edges.forEach(edge => {
          if (edge.from === node.id && !visited.has(edge.to)) {
            connectedNodes.push({ id: edge.to, direction: 'down' });
          } else if (edge.to === node.id && !visited.has(edge.from)) {
            connectedNodes.push({ id: edge.from, direction: 'up' });
          }
        });
        
        // Position connected nodes
        connectedNodes.forEach((n, index) => {
          const connectedNode = nodes[n.id];
          if (!connectedNode) return;
          
          const level = current.level + 1;
          const levelHeight = levelHeights[level] || 100;
          const levelStartY = root.y - levelHeight / 2;
          
          // Calculate position based on level and index
          const x = current.x;
          const y = levelStartY + (index * 100) + 50;
          
          queue.push({ node: connectedNode, x, y, level });
          visited.add(n.id);
        });
      }
    }
    
    function applyRadialLayout(rootId) {
      const root = nodes[rootId];
      const visited = new Set();
      const queue = [{ node: root, x: root.x, y: root.y, level: 0, angle: 0 }];
      visited.add(rootId);
      
      // First pass: count nodes per level
      const levelCounts = {};
      
      const measureQueue = [{ id: rootId, level: 0 }];
      const measureVisited = new Set([rootId]);
      
      while (measureQueue.length > 0) {
        const current = measureQueue.shift();
        const node = nodes[current.id];
        
        // Count nodes at this level
        levelCounts[current.level] = (levelCounts[current.level] || 0) + 1;
        
        // Find all connected nodes
        const connectedNodes = [];
        edges.forEach(edge => {
          if (edge.from === current.id && !measureVisited.has(edge.to)) {
            connectedNodes.push({ id: edge.to, level: current.level + 1 });
          } else if (edge.to === current.id && !measureVisited.has(edge.from)) {
            connectedNodes.push({ id: edge.from, level: current.level + 1 });
          }
        });
        
        // Add to queue
        connectedNodes.forEach(n => {
          measureQueue.push(n);
          measureVisited.add(n.id);
        });
      }
      
      // Second pass: position nodes
      while (queue.length > 0) {
        const current = queue.shift();
        const node = current.node;
        
        // Position the node
        node.x = current.x;
        node.y = current.y;
        
        const nodeEl = world.querySelector(`[data-id="${node.id}"]`);
        if (nodeEl) {
          nodeEl.style.left = node.x + 'px';
          nodeEl.style.top = node.y + 'px';
        }
        
        // Find all connected nodes
        const connectedNodes = [];
        edges.forEach(edge => {
          if (edge.from === node.id && !visited.has(edge.to)) {
            connectedNodes.push(edge.to);
          } else if (edge.to === node.id && !visited.has(edge.from)) {
            connectedNodes.push(edge.from);
          }
        });
        
        // Position connected nodes in a circle around the current node
        connectedNodes.forEach((nodeId, index) => {
          const connectedNode = nodes[nodeId];
          if (!connectedNode) return;
          
          const level = current.level + 1;
          const radius = level * 200;
          const angleStep = (2 * Math.PI) / connectedNodes.length;
          const angle = index * angleStep;
          
          const x = current.x + radius * Math.cos(angle);
          const y = current.y + radius * Math.sin(angle);
          
          queue.push({ node: connectedNode, x, y, level, angle });
          visited.add(nodeId);
        });
      }
    }
    
    // Initialize the application when the DOM is loaded
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>