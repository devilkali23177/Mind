<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Mind Map with Firebase Integration</title>
  <!-- Add Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <style>
    /* Your existing CSS styles remain unchanged */
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #111; 
      color: #fff; 
      touch-action: none;
    }
    #toolbar { 
      padding: 8px; 
      background: #222; 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      z-index: 10; 
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    #toolbar button, #toolbar select, #toolbar input { 
      padding: 10px 14px;
      background: #444; 
      color: white;
      border: 1px solid #666;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      min-height: 20px;
    }
    #toolbar button:hover, #toolbar select:hover {
      background: #555;
    }
    #toolbar button.active {
      background: #2a6b9b;
    }
    #toolbar input {
      background: #333;
      width: 100px;
      min-height: 20px;
    }
    #toolbar .separator {
      width: 1px;
      background: #444;
      margin: 0 8px;
      height: 24px;
    }
    #stage { 
      position: absolute; 
      top: 50px;
      left: 0; 
      right: 0; 
      bottom: 0; 
      overflow: auto; 
      -webkit-overflow-scrolling: touch;
    }
    #world { 
      position: relative; 
      width: 100000000000000000000000000000000000000000000000000000000000000000000px; 
      height: 100000000000000000000000000000000000000000000000000000000000000000000px; 
      transform-origin: 0 0;
      transition: transform 0.1s ease;
    }
    .node { 
      position: absolute; 
      min-width: 130px;
      max-width: 250px;
      padding: 12px 16px;
      background: #333; 
      border: 2px solid #666;
      border-radius: 10px;
      cursor: grab; 
      user-select: none; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      overflow: hidden;
      text-overflow: ellipsis;
      transition: transform 0.1s ease;
      font-size: 16px;
      touch-action: none;
    }
    .node:hover {
      transform: scale(1.02);
    }
    .node.selected { 
      border-color: #0ff; 
      box-shadow: 0 0 10px rgba(0,255,255,0.5);
    }
    .node.dragging {
      cursor: grabbing;
      opacity: 0.9;
    }
    .node-content {
      min-height: 24px;
      word-wrap: break-word;
    }
    svg { 
      position: absolute; 
      inset: 0; 
      pointer-events: none; 
    }
    line.connection {
      stroke: #0ff;
      stroke-width: 2;
    }
    line.connection.highlight {
      stroke: #ff0;
      stroke-width: 3;
    }
    #zoom-display {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 5;
    }
    .context-menu {
      position: fixed;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      z-index: 100;
      min-width: 150px;
    }
    .context-menu-item {
      padding: 12px 16px;
      cursor: pointer;
      font-size: 16px;
    }
    .context-menu-item:hover {
      background: #444;
    }
    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 10px;
      width: 140px;
    }
    .color-option {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #555;
    }
    .node-edit-input {
      position: absolute;
      background: #222;
      border: 2px solid #0ff;
      border-radius: 6px;
      padding: 8px;
      color: white;
      font: inherit;
      z-index: 20;
      min-width: 120px;
      resize: both;
      overflow: auto;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      font-size: 16px;
    }
    #edit-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      border: 2px solid #0ff;
      border-radius: 8px;
      padding: 20px;
      z-index: 100;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      width: 320px;
      display: none;
    }
    #edit-panel h3 {
      margin-top: 0;
      color: #0ff;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
      font-size: 18px;
    }
    #edit-textarea {
      width: 100%;
      height: 120px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 10px;
      resize: vertical;
      margin-bottom: 15px;
      font-family: inherit;
      font-size: 16px;
    }
    #edit-panel-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    #edit-panel button {
      padding: 10px 18px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      min-width: 80px;
    }
    #edit-panel-save {
      background: #2a6b9b;
      color: white;
    }
    #edit-panel-cancel {
      background: #555;
      color: white;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 90;
      display: none;
    }
    
    /* Firebase auth UI */
    #auth-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #auth-box {
      background: #333;
      padding: 30px;
      border-radius: 10px;
      width: 300px;
      text-align: center;
    }
    #auth-box h2 {
      margin-top: 0;
      color: #0ff;
    }
    #auth-box input {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: 1px solid #555;
      border-radius: 4px;
      background: #222;
      color: white;
      box-sizing: border-box;
    }
    #auth-box button {
      width: 100%;
      padding: 12px;
      margin: 5px 0;
      border: none;
      border-radius: 4px;
      background: #2a6b9b;
      color: white;
      cursor: pointer;
    }
    #auth-box p {
      margin: 15px 0 5px;
      color: #aaa;
    }
    #auth-message {
      color: #e74c3c;
      margin: 10px 0;
      min-height: 20px;
    }
    
    /* New Mind Map Manager UI */
    #map-manager-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    #map-manager-box {
      background: #333;
      padding: 20px;
      border-radius: 10px;
      width: 600px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
    }
    #map-manager-box h2 {
      margin-top: 0;
      color: #0ff;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #map-manager-box h2 span {
      font-size: 16px;
      color: #aaa;
    }
    #map-list-container {
      margin: 20px 0;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #555;
      border-radius: 4px;
      background: #222;
    }
    .map-list-header {
      display: grid;
      grid-template-columns: 1fr 120px 120px;
      padding: 10px 16px;
      background: #2a2a2a;
      font-weight: bold;
      border-bottom: 1px solid #444;
    }
    .map-item {
      display: grid;
      grid-template-columns: 1fr 120px 120px;
      padding: 12px 16px;
      border-bottom: 1px solid #444;
      align-items: center;
    }
    .map-item:hover {
      background: #3a3a3a;
    }
    .map-item.active {
      background: #2a6b9b;
    }
    .map-item-name {
      font-weight: bold;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .map-item-date {
      font-size: 13px;
      color: #aaa;
    }
    .map-item-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    .map-item-actions button {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .map-item-actions .load-btn {
      background: #2a6b9b;
      color: white;
    }
    .map-item-actions .rename-btn {
      background: #f39c12;
      color: white;
    }
    .map-item-actions .delete-btn {
      background: #e74c3c;
      color: white;
    }
    #new-map-section {
      margin: 20px 0;
      padding: 15px;
      background: #2a2a2a;
      border-radius: 6px;
    }
    #new-map-section h3 {
      margin-top: 0;
      color: #0ff;
    }
    #new-map-form {
      display: flex;
      gap: 10px;
    }
    #new-map-input {
      flex: 1;
      padding: 10px;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }
    #create-map-btn {
      padding: 10px 16px;
      background: #2ecc71;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #map-manager-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    #map-manager-buttons button {
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #close-map-manager {
      background: #555;
      color: white;
    }
    #current-map-info {
      margin: 10px 0;
      padding: 10px;
      background: #2a2a2a;
      border-radius: 4px;
      font-size: 14px;
    }
    
    /* Expand/Collapse Button Styles */
    .expand-toggle {
      position: absolute;
      right: 8px;
      top: 8px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #555;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .expand-toggle:hover {
      background: #777;
    }
    .node.collapsed > .expand-toggle::after {
      content: '+';
    }
    .node:not(.collapsed) > .expand-toggle::after {
      content: '-';
    }
    .node.collapsed .node-content {
      opacity: 0.8;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      #toolbar {
        padding: 6px;
        gap: 4px;
        overflow-x: auto;
        white-space: nowrap;
        height: 44px;
      }
      #toolbar button, #toolbar select, #toolbar input {
        padding: 8px 10px;
        font-size: 13px;
      }
      #stage {
        top: 46px;
      }
      .node {
        min-width: 110px;
        padding: 10px 12px;
        font-size: 15px;
      }
      #zoom-display {
        bottom: 5px;
        right: 5px;
        font-size: 12px;
        padding: 4px 8px;
      }
      #auth-box {
        width: 90%;
        max-width: 300px;
      }
      #map-manager-box {
        width: 95%;
        padding: 15px;
      }
      .map-list-header {
        grid-template-columns: 1fr 90px 90px;
        padding: 8px 12px;
        font-size: 12px;
      }
      .map-item {
        grid-template-columns: 1fr 90px 90px;
        padding: 10px 12px;
        font-size: 13px;
      }
      .map-item-actions {
        flex-direction: column;
        gap: 4px;
      }
      .map-item-actions button {
        padding: 4px 6px;
        font-size: 11px;
      }
      .expand-toggle {
        width: 14px;
        height: 14px;
        font-size: 10px;
        right: 6px;
        top: 6px;
      }
    }
    
    /* Prevent text selection on UI elements */
    .node, #toolbar button, .context-menu-item {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* Long press detection style */
    .long-press {
      animation: pulse 0.8s infinite alternate;
    }
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }
  </style>
</head>
<body>
  <!-- Firebase Auth UI -->
  <div id="auth-container">
    <div id="auth-box">
      <h2>Mind Map Login</h2>
      <div id="auth-message"></div>
      <input type="email" id="email-input" placeholder="Email">
      <input type="password" id="password-input" placeholder="Password">
      <button id="login-btn">Login</button>
      <button id="signup-btn">Sign Up</button>
      <p>Or continue as</p>
      <button id="guest-btn">Guest</button>
    </div>
  </div>

  <!-- New Mind Map Manager UI -->
  <div id="map-manager-container">
    <div id="map-manager-box">
      <h2>Mind Map Manager <span id="maps-count">(0 maps)</span></h2>
      
      <div id="current-map-info">
        Current Map: <span id="current-map-name">Default Map</span>
      </div>
      
      <div id="map-list-container">
        <div class="map-list-header">
          <div>Map Name</div>
          <div>Last Modified</div>
          <div>Actions</div>
        </div>
        <div id="map-list">
          <!-- Map items will be added here dynamically -->
        </div>
      </div>
      
      <div id="new-map-section">
        <h3>Create New Map</h3>
        <div id="new-map-form">
          <input type="text" id="new-map-input" placeholder="Enter map name">
          <button id="create-map-btn">Create New Map</button>
        </div>
      </div>
      
      <div id="map-manager-buttons">
        <button id="close-map-manager">Close Manager</button>
      </div>
    </div>
  </div>

  <div id="toolbar">
    <button id="addBtn">Add Node</button>
    <button id="connectBtn">Connect Nodes</button>
    <button id="editBtn">Edit Node</button>
    <button id="deleteBtn">Delete</button>
    <div class="separator"></div>
    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
    <button id="resetViewBtn">Reset View</button>
    <div class="separator"></div>
    <button id="colorBtn">Color</button>
    <button id="exportBtn">Export</button>
    <button id="importBtn">Import</button>
    <div class="separator"></div>
    <select id="layoutBtn">
      <option value="">Layout</option>
      <option value="horizontal">Horizontal</option>
      <option value="vertical">Vertical</option>
      <option value="radial">Radial</option>
    </select>
    <input type="text" id="searchInput" placeholder="Search nodes...">
    <div class="separator"></div>
    <button id="saveBtn">Save to Cloud</button>
    <button id="loadBtn">Load from Cloud</button>
    <button id="mapsBtn">Manage Maps</button>
    <button id="expandCollapseBtn">Expand/Collapse</button>
    <button id="logoutBtn" style="display:none;">Logout</button>
  </div>
  <div id="stage">
    <div id="world">
      <svg id="edges" width="100000000000000000000000000000000000000000000000000000000000000000000" height="100000000000000000000000000000000000000000000000000000000000000000000"></svg>
    </div>
  </div>
  <div id="zoom-display">100%</div>
  
  <!-- Edit Panel -->
  <div id="overlay"></div>
  <div id="edit-panel">
    <h3>Edit Node Content</h3>
    <textarea id="edit-textarea"></textarea>
    <div id="edit-panel-buttons">
      <button id="edit-panel-cancel">Cancel</button>
      <button id="edit-panel-save">Save</button>
    </div>
  </div>
  
  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBlQI16Nmx5oo3VzyCDEb6V4M2cH9Bbwc8",
      authDomain: "mindmapping-58435.firebaseapp.com",
      databaseURL: "https://mindmapping-58435-default-rtdb.firebaseio.com",
      projectId: "mindmapping-58435",
      storageBucket: "mindmapping-58435.firebasestorage.app",
      messagingSenderId: "1059085761579",
      appId: "1:1059085761579:web:5422cefb56f5989af7be6e",
      measurementId: "G-9F7EZZ2C9T"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const auth = firebase.auth();
    
    // Main application variables
    const world = document.getElementById('world');
    const stage = document.getElementById('stage');
    const edgesSVG = document.getElementById('edges');
    let nodes = {};
    let edges = [];
    let idCounter = 1;
    let connectMode = false;
    let editMode = false;
    let connectFrom = null;
    let selectedNode = null;
    let scale = 1;
    let panning = false;
    let startX, startY;
    let initialPinchDistance = null;
    let lastX = 0, lastY = 0;
    let activeEditInput = null;
    let longPressTimer = null;
    let isLongPress = false;
    let currentUser = null;
    let currentMapId = 'default';
    let mindMaps = {}; // Store all user's mind maps
    
    // New variables for fixing node dragging
    let isDraggingNode = false;
    let initialTouchPositions = null;
    
    // Variables for zooming from pointer position
    let zoomCenterX = 0;
    let zoomCenterY = 0;
    
    // Initialize the application
    function init() {
      // Setup auth event listeners
      setupAuthEventListeners();
      
      // Check if user was previously logged in
      const savedUser = localStorage.getItem('mindmap_user');
      if (savedUser) {
        try {
          currentUser = JSON.parse(savedUser);
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          initApp();
        } catch (e) {
          console.error('Error parsing saved user:', e);
          localStorage.removeItem('mindmap_user');
        }
      }
    }
    
    // Initialize the app after authentication
    function initApp() {
      // Add event listeners
      setupEventListeners();
      
      // Load list of mind maps
      loadMindMapsList();
      
      // Try to load from Firebase
      loadFromFirebase();
      
      // If no data, add initial node
      if (Object.keys(nodes).length === 0) {
        addNode(500, 500, 'Main Topic');
      }
      
      // Update zoom display
      updateZoomDisplay();
    }
    
    // Set up authentication event listeners
    function setupAuthEventListeners() {
      document.getElementById('login-btn').onclick = handleLogin;
      document.getElementById('signup-btn').onclick = handleSignup;
      document.getElementById('guest-btn').onclick = handleGuest;
      document.getElementById('logoutBtn').onclick = handleLogout;
      
      // Allow submitting with Enter key
      document.getElementById('email-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLogin();
      });
      document.getElementById('password-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLogin();
      });
    }
    
    // Handle user login
    function handleLogin() {
      const email = document.getElementById('email-input').value;
      const password = document.getElementById('password-input').value;
      const authMessage = document.getElementById('auth-message');
      
      if (!email || !password) {
        authMessage.textContent = 'Please enter both email and password';
        return;
      }
      
      authMessage.textContent = 'Logging in...';
      
      auth.signInWithEmailAndPassword(email, password)
        .then((userCredential) => {
          currentUser = userCredential.user;
          localStorage.setItem('mindmap_user', JSON.stringify({
            uid: currentUser.uid,
            email: currentUser.email
          }));
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          authMessage.textContent = '';
          initApp();
        })
        .catch((error) => {
          authMessage.textContent = error.message;
        });
    }
    
    // Handle user signup
    function handleSignup() {
      const email = document.getElementById('email-input').value;
      const password = document.getElementById('password-input').value;
      const authMessage = document.getElementById('auth-message');
      
      if (!email || !password) {
        authMessage.textContent = 'Please enter both email and password';
        return;
      }
      
      if (password.length < 6) {
        authMessage.textContent = 'Password should be at least 6 characters';
        return;
      }
      
      authMessage.textContent = 'Creating account...';
      
      auth.createUserWithEmailAndPassword(email, password)
        .then((userCredential) => {
          currentUser = userCredential.user;
          localStorage.setItem('mindmap_user', JSON.stringify({
            uid: currentUser.uid,
            email: currentUser.email
          }));
          document.getElementById('auth-container').style.display = 'none';
          document.getElementById('logoutBtn').style.display = 'block';
          authMessage.textContent = '';
          initApp();
        })
        .catch((error) => {
          authMessage.textContent = error.message;
        });
    }
    
    // Handle guest access
    function handleGuest() {
      currentUser = { uid: 'guest', email: 'guest@example.com' };
      document.getElementById('auth-container').style.display = 'none';
      initApp();
    }
    
    // Handle user logout
    function handleLogout() {
      auth.signOut().then(() => {
        currentUser = null;
        localStorage.removeItem('mindmap_user');
        document.getElementById('logoutBtn').style.display = 'none';
        document.getElementById('auth-container').style.display = 'flex';
        
        // Clear current mind map
        nodes = {};
        edges = [];
        idCounter = 1;
        world.querySelectorAll('.node').forEach(n => n.remove());
        edgesSVG.innerHTML = '';
        clearSelection();
      }).catch((error) => {
        console.error('Logout error:', error);
      });
    }
    
    // Set up all event listeners
    function setupEventListeners() {
      // Toolbar buttons
      document.getElementById('addBtn').onclick = () => {
        const x = 500 + Math.random() * 400;
        const y = 500 + Math.random() * 400;
        addNode(x, y, 'New Node');
        saveToFirebase(); // Auto-save after adding node
      };
      
      document.getElementById('connectBtn').onclick = () => {
        connectMode = !connectMode;
        editMode = false;
        document.getElementById('connectBtn').classList.toggle('active', connectMode);
        document.getElementById('editBtn').classList.remove('active');
        connectFrom = null;
        clearSelection();
      };
      
      document.getElementById('editBtn').onclick = () => {
        editMode = !editMode;
        connectMode = false;
        document.getElementById('editBtn').classList.toggle('active', editMode);
        document.getElementById('connectBtn').classList.remove('active');
      };
      
      document.getElementById('deleteBtn').onclick = () => {
        deleteSelected();
        saveToFirebase(); // Auto-save after deletion
      };
      
      document.getElementById('zoomInBtn').onclick = () => adjustZoom(0.1);
      document.getElementById('zoomOutBtn').onclick = () => adjustZoom(-0.1);
      document.getElementById('resetViewBtn').onclick = resetView;
      
      document.getElementById('colorBtn').onclick = showColorMenu;
      document.getElementById('exportBtn').onclick = exportData;
      document.getElementById('importBtn').onclick = () => document.getElementById('importInput')?.click() || createImportInput();
      
      document.getElementById('layoutBtn').onchange = (e) => {
        if (e.target.value) {
          applyLayout(e.target.value);
          saveToFirebase(); // Auto-save after layout change
        }
      };
      
      document.getElementById('searchInput').oninput = (e) => {
        searchNodes(e.target.value);
      };
      
      // Firebase save/load buttons
      document.getElementById('saveBtn').onclick = saveToFirebase;
      document.getElementById('loadBtn').onclick = loadFromFirebase;
      
      // Map management button
      document.getElementById('mapsBtn').onclick = showMapManager;
      
      // Expand/Collapse button
      document.getElementById('expandCollapseBtn').onclick = toggleExpandCollapse;
      
      // Edit panel buttons
      document.getElementById('edit-panel-save').onclick = () => {
        saveEditPanel();
        saveToFirebase(); // Auto-save after editing
      };
      document.getElementById('edit-panel-cancel').onclick = closeEditPanel;
      document.getElementById('overlay').onclick = closeEditPanel;
      
      // Map manager event listeners
      document.getElementById('create-map-btn').onclick = createNewMap;
      document.getElementById('close-map-manager').onclick = hideMapManager;
      
      // Allow Enter key to create new map
      document.getElementById('new-map-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') createNewMap();
      });
      
      // Panning and zooming
      stage.addEventListener('wheel', handleWheel, { passive: false });
      stage.addEventListener('mousedown', startPan);
      document.addEventListener('mousemove', handlePan);
      document.addEventListener('mouseup', stopPan);
      
      // Touch events for mobile - UPDATED
      setupTouchEvents();
      
      // Context menu
      stage.addEventListener('contextmenu', handleContextMenu);
      
      // Click outside to clear selection
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.node') && !e.target.closest('.context-menu') && 
            !e.target.closest('.node-edit-input') && !e.target.closest('#edit-panel') &&
            !e.target.closest('#map-manager-container') && !e.target.closest('.expand-toggle')) {
          clearSelection();
          hideContextMenu();
        }
      });
      
      // Double click to edit
      stage.addEventListener('dblclick', (e) => {
        const node = e.target.closest('.node');
        if (node && !e.target.closest('.expand-toggle')) {
          const nodeId = node.dataset.id;
          selectNode(nodeId);
          showEditPanel(nodes[nodeId]);
        }
      });
      
      // Auto-save on node drag end
      document.addEventListener('mouseup', () => {
        if (isDraggingNode) {
          saveToFirebase();
          isDraggingNode = false;
        }
      });
    }
    
    // Save mind map to Firebase
    function saveToFirebase() {
      if (!currentUser) return;
      
      const data = {
        nodes: Object.values(nodes),
        edges: edges,
        idCounter: idCounter,
        lastUpdated: Date.now(),
        name: getCurrentMapName()
      };
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${currentMapId}`).set(data)
        .then(() => {
          console.log('Data saved successfully to Firebase');
          // Show a temporary save confirmation
          const saveBtn = document.getElementById('saveBtn');
          const originalText = saveBtn.textContent;
          saveBtn.textContent = 'Saved!';
          setTimeout(() => {
            saveBtn.textContent = originalText;
          }, 2000);
          
          // Refresh the map list to show updated timestamp
          loadMindMapsList();
        })
        .catch((error) => {
          console.error('Error saving data to Firebase:', error);
          alert('Failed to save to cloud: ' + error.message);
        });
    }
    
    // Get current map name
    function getCurrentMapName() {
      if (currentMapId === 'default') return 'Default Map';
      if (mindMaps[currentMapId] && mindMaps[currentMapId].name) {
        return mindMaps[currentMapId].name;
      }
      return currentMapId;
    }
    
    // Load mind map from Firebase
    function loadFromFirebase() {
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${currentMapId}`).once('value')
        .then((snapshot) => {
          const data = snapshot.val();
          if (data) {
            loadData(data);
            console.log('Data loaded successfully from Firebase');
            updateCurrentMapInfo();
          } else {
            console.log('No data found in Firebase, using local data');
            // Create a new empty map if none exists
            if (Object.keys(nodes).length === 0) {
              addNode(500, 500, 'Main Topic');
            }
            updateCurrentMapInfo();
          }
        })
        .catch((error) => {
          console.error('Error loading data from Firebase:', error);
          alert('Failed to load from cloud: ' + error.message);
        });
    }
    
    // Update current map info display
    function updateCurrentMapInfo() {
      document.getElementById('current-map-name').textContent = getCurrentMapName();
    }
    
    // Load list of all mind maps for the current user
    function loadMindMapsList() {
      if (!currentUser) return;
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(userPath).once('value')
        .then((snapshot) => {
          const maps = snapshot.val();
          mindMaps = maps || {};
          renderMapsList();
        })
        .catch((error) => {
          console.error('Error loading mind maps list:', error);
        });
    }
    
    // Render the list of mind maps in the manager UI
    function renderMapsList() {
      const mapList = document.getElementById('map-list');
      mapList.innerHTML = '';
      
      // Update maps count
      const mapsCount = Object.keys(mindMaps).length;
      document.getElementById('maps-count').textContent = `(${mapsCount} maps)`;
      
      if (!mindMaps || mapsCount === 0) {
        mapList.innerHTML = '<div class="map-item" style="grid-column: 1 / span 3; justify-content: center; cursor: default;">No maps found</div>';
        return;
      }
      
      Object.entries(mindMaps).forEach(([mapId, mapData]) => {
        const mapItem = document.createElement('div');
        mapItem.className = 'map-item';
        if (mapId === currentMapId) {
          mapItem.classList.add('active');
        }
        
        // Map name
        const mapName = document.createElement('div');
        mapName.className = 'map-item-name';
        mapName.textContent = mapData.name || mapId;
        mapName.title = mapData.name || mapId;
        mapName.onclick = () => switchToMap(mapId);
        
        // Last modified date
        const mapDate = document.createElement('div');
        mapDate.className = 'map-item-date';
        mapDate.textContent = mapData.lastUpdated ? 
          new Date(mapData.lastUpdated).toLocaleDateString() : 'Unknown';
        
        // Action buttons
        const mapActions = document.createElement('div');
        mapActions.className = 'map-item-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.className = 'load-btn';
        loadBtn.onclick = () => switchToMap(mapId);
        
        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'Rename';
        renameBtn.className = 'rename-btn';
        renameBtn.onclick = () => renameMap(mapId);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.className = 'delete-btn';
        deleteBtn.onclick = () => deleteMap(mapId);
        
        mapActions.appendChild(loadBtn);
        mapActions.appendChild(renameBtn);
        mapActions.appendChild(deleteBtn);
        
        mapItem.appendChild(mapName);
        mapItem.appendChild(mapDate);
        mapItem.appendChild(mapActions);
        
        mapList.appendChild(mapItem);
      });
    }
    
    // Switch to a different mind map
    function switchToMap(mapId) {
      // Save current map first
      saveToFirebase();
      
      // Clear current data
      nodes = {};
      edges = [];
      idCounter = 1;
      world.querySelectorAll('.node').forEach(n => n.remove());
      edgesSVG.innerHTML = '';
      clearSelection();
      
      // Set new map ID and load
      currentMapId = mapId;
      loadFromFirebase();
      hideMapManager();
    }
    
    // Create a new mind map
    function createNewMap() {
      const mapNameInput = document.getElementById('new-map-input');
      const mapName = mapNameInput.value.trim();
      
      if (!mapName) {
        alert('Please enter a name for your new mind map');
        return;
      }
      
      // Generate a unique ID for the map
      const mapId = 'map_' + Date.now();
      
      // Create initial data for the new map
      const initialData = {
        nodes: [{
          id: 1,
          x: 500,
          y: 500,
          text: 'Main Topic',
          color: '#333',
          borderColor: '#666',
          expanded: true
        }],
        edges: [],
        idCounter: 2,
        lastUpdated: Date.now(),
        name: mapName,
        createdAt: Date.now()
      };
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}`).set(initialData)
        .then(() => {
          // Add the new map to our local list
          mindMaps[mapId] = initialData;
          renderMapsList();
          
          // Clear the input field
          mapNameInput.value = '';
          
          // Switch to the new map
          switchToMap(mapId);
        })
        .catch((error) => {
          console.error('Error creating new map:', error);
          alert('Failed to create new map: ' + error.message);
        });
    }
    
    // Rename a mind map
    function renameMap(mapId) {
      const currentName = mindMaps[mapId]?.name || mapId;
      const newName = prompt('Enter a new name for this mind map:', currentName);
      
      if (newName && newName.trim()) {
        const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
        
        database.ref(`${userPath}/${mapId}/name`).set(newName.trim())
          .then(() => {
            // Update local data
            if (mindMaps[mapId]) {
              mindMaps[mapId].name = newName.trim();
            } else {
              mindMaps[mapId] = { name: newName.trim() };
            }
            
            // If this is the current map, update the display
            if (mapId === currentMapId) {
              updateCurrentMapInfo();
            }
            
            renderMapsList();
          })
          .catch((error) => {
            console.error('Error renaming map:', error);
            alert('Failed to rename map: ' + error.message);
          });
      }
    }
    
    // Delete a mind map
    function deleteMap(mapId) {
      if (!confirm('Are you sure you want to delete this mind map? This action cannot be undone.')) {
        return;
      }
      
      const userPath = currentUser.uid === 'guest' ? 'guest_maps' : `users/${currentUser.uid}/maps`;
      
      database.ref(`${userPath}/${mapId}`).remove()
        .then(() => {
          // Remove from local data
          delete mindMaps[mapId];
          
          // If we're currently viewing the deleted map, switch to default
          if (currentMapId === mapId) {
            currentMapId = 'default';
            // Clear current data
            nodes = {};
            edges = [];
            idCounter = 1;
            world.querySelectorAll('.node').forEach(n => n.remove());
            edgesSVG.innerHTML = '';
            clearSelection();
            
            // Create a default node
            addNode(500, 500, 'Main Topic');
            updateCurrentMapInfo();
          }
          
          renderMapsList();
        })
        .catch((error) => {
          console.error('Error deleting map:', error);
          alert('Failed to delete map: ' + error.message);
        });
    }
    
    // Show the mind map manager UI
    function showMapManager() {
      loadMindMapsList();
      document.getElementById('map-manager-container').style.display = 'flex';
    }
    
    // Hide the mind map manager UI
    function hideMapManager() {
      document.getElementById('map-manager-container').style.display = 'none';
    }
    
    // Load data into the application
    function loadData(data) {
      // Clear existing nodes and edges
      world.querySelectorAll('.node').forEach(n => n.remove());
      edgesSVG.innerHTML = '';
      nodes = {};
      edges = data.edges || [];
      idCounter = data.idCounter || 1;
      
      // Create nodes
      if (data.nodes && data.nodes.length > 0) {
        data.nodes.forEach(node => {
          createNodeElement(node);
          nodes[node.id] = node;
        });
      } else {
        // If no nodes, create a default one
        addNode(500, 500, 'Main Topic');
      }
      
      // Draw edges
      drawEdges();
      
      // Clear selection
      clearSelection();
      
      // Update current map info
      updateCurrentMapInfo();
    }
    
    // Create a node element from node data
    function createNodeElement(node) {
      const nodeElement = document.createElement('div');
      nodeElement.className = 'node';
      nodeElement.dataset.id = node.id;
      nodeElement.style.left = node.x + 'px';
      nodeElement.style.top = node.y + 'px';
      nodeElement.style.backgroundColor = node.color || '#333';
      nodeElement.style.borderColor = node.borderColor || '#666';
      
      // Add expand/collapse toggle button
      const expandToggle = document.createElement('div');
      expandToggle.className = 'expand-toggle';
      expandToggle.onclick = (e) => {
        e.stopPropagation();
        toggleNode(node.id);
      };
      nodeElement.appendChild(expandToggle);
      
      const contentDiv = document.createElement('div');
      contentDiv.className = 'node-content';
      contentDiv.textContent = node.text;
      
      nodeElement.appendChild(contentDiv);
      world.appendChild(nodeElement);
      
      // Add event listeners
      setupNodeEventListeners(nodeElement);
      
      return nodeElement;
    }
    
    // Set up event listeners for a node
    function setupNodeEventListeners(nodeElement) {
      // Mouse events
      nodeElement.addEventListener('mousedown', handleNodeMouseDown);
      
      // Touch events - UPDATED
      nodeElement.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
      nodeElement.addEventListener('touchmove', handleNodeTouchMove, { passive: false });
      nodeElement.addEventListener('touchend', handleNodeTouchEnd);
      nodeElement.addEventListener('touchcancel', handleNodeTouchEnd);
      
      // Click to select
      nodeElement.addEventListener('click', (e) => {
        e.stopPropagation();
        
        if (isLongPress) {
          isLongPress = false;
          return;
        }
        
        // Don't process clicks on the expand toggle button
        if (e.target.closest('.expand-toggle')) {
          return;
        }
        
        const nodeId = nodeElement.dataset.id;
        
        if (connectMode) {
          if (!connectFrom) {
            connectFrom = nodeId;
            nodeElement.classList.add('selected');
            saveToFirebase(); // Auto-save after selecting connection start
          } else if (connectFrom !== nodeId) {
            addEdge(connectFrom, nodeId);
            connectMode = false;
            document.getElementById('connectBtn').classList.remove('active');
            clearSelection();
            saveToFirebase(); // Auto-save after adding connection
          }
        } else if (editMode) {
          selectNode(nodeId);
          showEditPanel(nodes[nodeId]);
        } else {
          selectNode(nodeId);
        }
      });
      
      // Long press for mobile context menu
      nodeElement.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            const nodeId = nodeElement.dataset.id;
            selectNode(nodeId);
            showContextMenu(e.touches[0].clientX, e.touches[0].clientY, nodes[nodeId]);
            e.preventDefault();
          }, 500);
        }
      });
      
      nodeElement.addEventListener('touchend', () => {
        clearTimeout(longPressTimer);
      });
      
      nodeElement.addEventListener('touchmove', () => {
        clearTimeout(longPressTimer);
      });
    }
    
    // Add a new node
    function addNode(x, y, text) {
      const id = idCounter++;
      const node = {
        id: id,
        x: x,
        y: y,
        text: text || 'New Node',
        color: '#333',
        borderColor: '#666',
        expanded: true // Default to expanded
      };
      
      nodes[id] = node;
      createNodeElement(node);
      
      return node;
    }
    
    // Add an edge between two nodes
    function addEdge(fromId, toId) {
      // Check if edge already exists
      if (edges.some(edge => edge.from === fromId && edge.to === toId)) {
        return;
      }
      
      edges.push({ from: fromId, to: toId });
      drawEdges();
    }
    
    // Draw all edges
    function drawEdges() {
      edgesSVG.innerHTML = '';
      
      edges.forEach(edge => {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];
        
        if (fromNode && toNode) {
          // Check if either node is collapsed and should hide connections
          if (isNodeHiddenByCollapse(fromNode.id) || isNodeHiddenByCollapse(toNode.id)) {
            return;
          }
          
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('class', 'connection');
          line.setAttribute('x1', fromNode.x + 65);
          line.setAttribute('y1', fromNode.y + 20);
          line.setAttribute('x2', toNode.x + 65);
          line.setAttribute('y2', toNode.y + 20);
          line.setAttribute('data-from', fromNode.id);
          line.setAttribute('data-to', toNode.id);
          
          edgesSVG.appendChild(line);
        }
      });
    }
    
    // Select a node
    function selectNode(nodeId) {
      clearSelection();
      
      const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
      if (nodeElement) {
        nodeElement.classList.add('selected');
        selectedNode = nodes[nodeId];
        
        // Highlight connected edges
        document.querySelectorAll(`line[data-from="${nodeId}"], line[data-to="${nodeId}"]`).forEach(line => {
          line.classList.add('highlight');
        });
      }
    }
    
    // Clear selection
    function clearSelection() {
      document.querySelectorAll('.node.selected').forEach(node => {
        node.classList.remove('selected');
      });
      
      document.querySelectorAll('.connection.highlight').forEach(line => {
        line.classList.remove('highlight');
      });
      
      selectedNode = null;
      connectFrom = null;
    }
    
    // Delete selected node or edge
    function deleteSelected() {
      if (selectedNode) {
        // Delete the node and its connections
        const nodeId = selectedNode.id;
        
        // Remove node from DOM
        const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
        if (nodeElement) {
          nodeElement.remove();
        }
        
        // Remove node from data
        delete nodes[nodeId];
        
        // Remove any edges connected to this node
        edges = edges.filter(edge => edge.from !== nodeId && edge.to !== nodeId);
        
        // Redraw edges
        drawEdges();
        
        // Clear selection
        clearSelection();
      }
    }
    
    // Show edit panel for a node
    function showEditPanel(node) {
      const editPanel = document.getElementById('edit-panel');
      const editTextarea = document.getElementById('edit-textarea');
      const overlay = document.getElementById('overlay');
      
      editTextarea.value = node.text;
      editPanel.style.display = 'block';
      overlay.style.display = 'block';
      
      // Store which node we're editing
      editPanel.dataset.editingNode = node.id;
    }
    
    // Close edit panel
    function closeEditPanel() {
      document.getElementById('edit-panel').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
    }
    
    // Save changes from edit panel
    function saveEditPanel() {
      const editPanel = document.getElementById('edit-panel');
      const editTextarea = document.getElementById('edit-textarea');
      const nodeId = editPanel.dataset.editingNode;
      
      if (nodeId && nodes[nodeId]) {
        // Update the node text in the data model
        nodes[nodeId].text = editTextarea.value;
        
        // Update the node text in the DOM
        const nodeElement = document.querySelector(`.node[data-id="${nodeId}"] .node-content`);
        if (nodeElement) {
          nodeElement.textContent = editTextarea.value;
        }
      }
      
      closeEditPanel();
    }
    
    // Show color menu
    function showColorMenu() {
      if (!selectedNode) return;
      
      const colors = [
        '#2c3e50', '#34495e', '#16a085', '#27ae60', '#2980b9',
        '#8e44ad', '#2c3e50', '#f39c12', '#d35400', '#c0392b',
        '#7f8c8d', '#1abc9c', '#3498db', '#9b59b6', '#e74c3c'
      ];
      
      // Create color picker menu
      hideContextMenu();
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = '<div style="padding: 10px; font-weight: bold;">Choose Color</div>';
      
      const colorGrid = document.createElement('div');
      colorGrid.className = 'color-picker';
      
      colors.forEach(color => {
        const colorOption = document.createElement('div');
        colorOption.className = 'color-option';
        colorOption.style.backgroundColor = color;
        colorOption.onclick = () => {
          changeNodeColor(selectedNode.id, color);
          hideContextMenu();
          saveToFirebase(); // Auto-save after color change
        };
        colorGrid.appendChild(colorOption);
      });
      
      menu.appendChild(colorGrid);
      document.body.appendChild(menu);
      
      // Position menu near selected node
      const nodeElement = document.querySelector(`.node[data-id="${selectedNode.id}"]`);
      if (nodeElement) {
        const rect = nodeElement.getBoundingClientRect();
        menu.style.left = rect.right + 10 + 'px';
        menu.style.top = rect.top + 'px';
      }
    }
    
    // Change node color
    function changeNodeColor(nodeId, color) {
      if (nodes[nodeId]) {
        nodes[nodeId].color = color;
        const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
        if (nodeElement) {
          nodeElement.style.backgroundColor = color;
        }
      }
    }
    
    // Export data as JSON
    function exportData() {
      const data = {
        nodes: Object.values(nodes),
        edges: edges,
        idCounter: idCounter
      };
      
      const dataStr = JSON.stringify(data, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
      
      const exportFileDefaultName = 'mindmap.json';
      
      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileDefaultName);
      linkElement.click();
    }
    
    // Create import input if it doesn't exist
    function createImportInput() {
      const input = document.createElement('input');
      input.type = 'file';
      input.id = 'importInput';
      input.accept = '.json';
      input.style.display = 'none';
      input.onchange = handleImport;
      document.body.appendChild(input);
      input.click();
    }
    
    // Handle imported file
    function handleImport(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          loadData(data);
          saveToFirebase(); // Save imported data to Firebase
        } catch (error) {
          alert('Error parsing JSON file: ' + error.message);
        }
      };
      reader.readAsText(file);
    }
    
    // Apply layout to nodes
    function applyLayout(type) {
      const centerX = 500;
      const centerY = 500;
      const nodeValues = Object.values(nodes);
      
      if (type === 'horizontal') {
        // Simple horizontal layout with root in center
        const root = nodeValues[0] || addNode(centerX, centerY, 'Main Topic');
        root.x = centerX;
        root.y = centerY;
        
        let xOffset = 200;
        nodeValues.forEach((node, i) => {
          if (node.id !== root.id) {
            node.x = centerX + xOffset;
            node.y = centerY + (i % 2 === 0 ? -100 : 100);
            xOffset += 200;
          }
        });
      } else if (type === 'vertical') {
        // Simple vertical layout with root in center
        const root = nodeValues[0] || addNode(centerX, centerY, 'Main Topic');
        root.x = centerX;
        root.y = centerY;
        
        let yOffset = 100;
        nodeValues.forEach((node, i) => {
          if (node.id !== root.id) {
            node.x = centerX + (i % 2 === 0 ? -150 : 150);
            node.y = centerY + yOffset;
            yOffset += 100;
          }
        });
      } else if (type === 'radial') {
        // Simple radial layout
        const root = nodeValues[0] || addNode(centerX, centerY, 'Main Topic');
        root.x = centerX;
        root.y = centerY;
        
        const radius = 200;
        const angleStep = (2 * Math.PI) / (nodeValues.length - 1);
        
        let angle = 0;
        nodeValues.forEach(node => {
          if (node.id !== root.id) {
            node.x = centerX + radius * Math.cos(angle);
            node.y = centerY + radius * Math.sin(angle);
            angle += angleStep;
          }
        });
      }
      
      // Update node positions in DOM
      nodeValues.forEach(node => {
        const nodeElement = document.querySelector(`.node[data-id="${node.id}"]`);
        if (nodeElement) {
          nodeElement.style.left = node.x + 'px';
          nodeElement.style.top = node.y + 'px';
        }
      });
      
      // Redraw edges
      drawEdges();
    }
    
    // Search nodes
    function searchNodes(query) {
      clearSelection();
      
      if (!query) {
        // Reset all nodes if search is empty
        Object.values(nodes).forEach(node => {
          const nodeElement = document.querySelector(`.node[data-id="${node.id}"]`);
          if (nodeElement) {
            nodeElement.style.opacity = 1;
          }
        });
        return;
      }
      
      const lowerQuery = query.toLowerCase();
      
      Object.values(nodes).forEach(node => {
        const nodeElement = document.querySelector(`.node[data-id="${node.id}"]`);
        if (nodeElement) {
          if (node.text.toLowerCase().includes(lowerQuery)) {
            nodeElement.style.opacity = 1;
          } else {
            nodeElement.style.opacity = 0.3;
          }
        }
      });
    }
    
    // Adjust zoom level with center point
    function adjustZoom(delta, centerX, centerY) {
      // If center coordinates are not provided, use the center of the stage
      const stageRect = stage.getBoundingClientRect();
      if (centerX === undefined) centerX = stageRect.width / 2;
      if (centerY === undefined) centerY = stageRect.height / 2;
      
      // Calculate the current scroll position
      const scrollX = stage.scrollLeft;
      const scrollY = stage.scrollTop;
      
      // Calculate the cursor position relative to the world
      const cursorX = scrollX + centerX;
      const cursorY = scrollY + centerY;
      
      // Calculate the new scale
      const newScale = Math.max(0.1, Math.min(5, scale + delta));
      
      // Calculate the zoom factor
      const zoomFactor = newScale / scale;
      
      // Adjust the scroll position to zoom towards the cursor
      stage.scrollLeft = cursorX * zoomFactor - centerX;
      stage.scrollTop = cursorY * zoomFactor - centerY;
      
      // Apply the new scale
      scale = newScale;
      world.style.transform = `scale(${scale})`;
      
      updateZoomDisplay();
    }
    
    // Update zoom display
    function updateZoomDisplay() {
      document.getElementById('zoom-display').textContent = Math.round(scale * 100) + '%';
    }
    
    // Reset view
    function resetView() {
      scale = 1;
      world.style.transform = 'scale(1)';
      stage.scrollLeft = 0;
      stage.scrollTop = 0;
      updateZoomDisplay();
    }
    
    // Handle mouse wheel for zooming
    function handleWheel(e) {
      e.preventDefault();
      
      if (e.ctrlKey) {
        // Zoom with Ctrl+Wheel
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        adjustZoom(delta, e.clientX, e.clientY);
      } else {
        // Pan with regular wheel
        stage.scrollLeft += e.deltaX;
        stage.scrollTop += e.deltaY;
      }
    }
    
    // Start panning
    function startPan(e) {
      if (e.button !== 1 && !e.touches) return; // Only middle mouse button or touch
      
      panning = true;
      startX = e.clientX || e.touches[0].clientX;
      startY = e.clientY || e.touches[0].clientY;
      lastX = stage.scrollLeft;
      lastY = stage.scrollTop;
      
      e.preventDefault();
    }
    
    // Handle panning
    function handlePan(e) {
      if (!panning) return;
      
      const x = e.clientX || (e.touches && e.touches[0].clientX);
      const y = e.clientY || (e.touches && e.touches[0].clientY);
      
      if (x === undefined || y === undefined) return;
      
      const dx = x - startX;
      const dy = y - startY;
      
      stage.scrollLeft = lastX - dx;
      stage.scrollTop = lastY - dy;
      
      e.preventDefault();
    }
    
    // Stop panning
    function stopPan() {
      panning = false;
    }
    
    // Set up touch events - UPDATED
    function setupTouchEvents() {
      // Use a single touch event handler for the stage to avoid conflicts
      const stage = document.getElementById('stage');
      
      stage.addEventListener('touchstart', (e) => {
        // If touching a node, let the node handle it
        if (e.target.closest('.node')) {
          return;
        }
        
        if (e.touches.length === 2) {
          // Pinch to zoom
          initialPinchDistance = getDistance(
            e.touches[0].clientX, e.touches[0].clientY,
            e.touches[1].clientX, e.touches[1].clientY
          );
          
          // Calculate the center point between the two touches
          zoomCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          zoomCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          
          e.preventDefault();
        } else if (e.touches.length === 1) {
          // Start panning
          startPan(e);
        }
      }, { passive: false });
      
      stage.addEventListener('touchmove', (e) => {
        // If touching a node, let the node handle it
        if (e.target.closest('.node')) {
          return;
        }
        
        if (e.touches.length === 2) {
          // Handle pinch zoom
          const currentDistance = getDistance(
            e.touches[0].clientX, e.touches[0].clientY,
            e.touches[1].clientX, e.touches[1].clientY
          );
          
          if (initialPinchDistance !== null) {
            const delta = (currentDistance - initialPinchDistance) / 100;
            adjustZoom(delta * 0.1, zoomCenterX, zoomCenterY);
            initialPinchDistance = currentDistance;
          }
          
          e.preventDefault();
        } else if (e.touches.length === 1 && panning) {
          handlePan(e);
        }
      }, { passive: false });
      
      stage.addEventListener('touchend', (e) => {
        // If touching a node, let the node handle it
        if (e.target.closest('.node')) {
          return;
        }
        
        initialPinchDistance = null;
        stopPan();
      });
      
      stage.addEventListener('touchcancel', (e) => {
        // If touching a node, let the node handle it
        if (e.target.closest('.node')) {
          return;
        }
        
        initialPinchDistance = null;
        stopPan();
      });
    }
    
    // Calculate distance between two points
    function getDistance(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    
    // Handle node mouse down for dragging
    function handleNodeMouseDown(e) {
      if (e.button !== 0) return; // Only left mouse button
      
      const nodeElement = e.target.closest('.node');
      if (!nodeElement) return;
      
      const nodeId = nodeElement.dataset.id;
      const node = nodes[nodeId];
      if (!node) return;
      
      // Select the node
      selectNode(nodeId);
      
      // Start dragging
      isDraggingNode = true;
      const offsetX = e.clientX - node.x;
      const offsetY = e.clientY - node.y;
      
      function handleMouseMove(e) {
        node.x = e.clientX - offsetX;
        node.y = e.clientY - offsetY;
        nodeElement.style.left = node.x + 'px';
        nodeElement.style.top = node.y + 'px';
        
        // Update edges
        drawEdges();
      }
      
      function handleMouseUp() {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        isDraggingNode = false;
      }
      
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      e.preventDefault();
    }
    
    // Handle node touch start for dragging on mobile - UPDATED
    function handleNodeTouchStart(e) {
      if (e.touches.length !== 1) return;
      
      const nodeElement = e.target.closest('.node');
      if (!nodeElement) return;
      
      const nodeId = nodeElement.dataset.id;
      const node = nodes[nodeId];
      if (!node) return;
      
      // Select the node
      selectNode(nodeId);
      
      // Start dragging
      isDraggingNode = true;
      const touch = e.touches[0];
      initialTouchPositions = {
        touchX: touch.clientX,
        touchY: touch.clientY,
        nodeX: node.x,
        nodeY: node.y
      };
      
      e.preventDefault();
    }
    
    // Handle node touch move for dragging on mobile - UPDATED
    function handleNodeTouchMove(e) {
      if (!initialTouchPositions || e.touches.length !== 1) return;
      
      const nodeElement = e.target.closest('.node');
      if (!nodeElement) return;
      
      const nodeId = nodeElement.dataset.id;
      const node = nodes[nodeId];
      if (!node) return;
      
      const touch = e.touches[0];
      const dx = touch.clientX - initialTouchPositions.touchX;
      const dy = touch.clientY - initialTouchPositions.touchY;
      
      node.x = initialTouchPositions.nodeX + dx;
      node.y = initialTouchPositions.nodeY + dy;
      nodeElement.style.left = node.x + 'px';
      nodeElement.style.top = node.y + 'px';
      
      // Update edges
      drawEdges();
      
      e.preventDefault();
    }
    
    // Handle node touch end for dragging on mobile - UPDATED
    function handleNodeTouchEnd(e) {
      // Only save if we were actually dragging a node
      if (isDraggingNode) {
        saveToFirebase();
        isDraggingNode = false;
      }
      initialTouchPositions = null;
    }
    
    // Handle context menu
    function handleContextMenu(e) {
      e.preventDefault();
      
      const node = e.target.closest('.node');
      if (node) {
        const nodeId = node.dataset.id;
        selectNode(nodeId);
        showContextMenu(e.clientX, e.clientY, nodes[nodeId]);
      } else {
        hideContextMenu();
      }
    }
    
    // Show context menu - FIXED: Hide menu after selecting an option
    function showContextMenu(x, y, node) {
      hideContextMenu();
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      
      const menuItems = [
        { text: 'Edit', action: () => showEditPanel(node) },
        { text: 'Change Color', action: () => showColorMenu() },
        { text: 'Delete', action: () => { deleteSelected(); saveToFirebase(); } },
        { text: 'Add Child Node', action: () => {
          const childX = node.x + 200;
          const childY = node.y;
          const childNode = addNode(childX, childY, 'Child Node');
          addEdge(node.id, childNode.id);
          saveToFirebase(); // Auto-save after adding child
        }},
        { text: nodes[node.id].expanded ? 'Collapse' : 'Expand', action: () => {
          toggleNode(node.id);
        }}
      ];
      
      menuItems.forEach(item => {
        const menuItem = document.createElement('div');
        menuItem.className = 'context-menu-item';
        menuItem.textContent = item.text;
        menuItem.onclick = () => {
          item.action();
          hideContextMenu(); // Hide menu after selecting an option
        };
        menu.appendChild(menuItem);
      });
      
      document.body.appendChild(menu);
      
      // Position menu
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
    }
    
    // Hide context menu
    function hideContextMenu() {
      const menu = document.querySelector('.context-menu');
      if (menu) {
        menu.remove();
      }
    }
    
    // EXPAND/COLLAPSE FUNCTIONALITY
    
    // Toggle expand/collapse for a specific node
    function toggleNode(nodeId) {
      if (!nodes[nodeId]) return;
      
      // Toggle the expanded state
      nodes[nodeId].expanded = !nodes[nodeId].expanded;
      
      // Update the UI
      const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
      if (nodeElement) {
        if (nodes[nodeId].expanded) {
          nodeElement.classList.remove('collapsed');
        } else {
          nodeElement.classList.add('collapsed');
        }
      }
      
      // Update visibility of child nodes and edges
      updateNodeVisibility(nodeId);
      
      // Save to Firebase
      saveToFirebase();
    }
    
    // Check if a node is hidden due to a parent being collapsed
    function isNodeHiddenByCollapse(nodeId) {
      let currentId = nodeId;
      
      // Traverse up the hierarchy to see if any parent is collapsed
      while (currentId) {
        const node = nodes[currentId];
        if (!node || !node.expanded) {
          return true;
        }
        
        // Find the parent of this node (if any)
        const parentEdge = edges.find(edge => edge.to == currentId);
        if (!parentEdge) {
          break; // No parent found, we've reached the root
        }
        
        currentId = parentEdge.from;
      }
      
      return false;
    }
    
    // Update visibility for a node and its children
    function updateNodeVisibility(nodeId) {
      const node = nodes[nodeId];
      if (!node) return;
      
      const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
      if (!nodeElement) return;
      
      // Show or hide based on expanded state
      if (node.expanded) {
        nodeElement.classList.remove('collapsed');
      } else {
        nodeElement.classList.add('collapsed');
      }
      
      // Get all direct children of this node
      const childEdges = edges.filter(edge => edge.from == nodeId);
      
      for (const edge of childEdges) {
        const childId = edge.to;
        const childNode = nodes[childId];
        if (childNode) {
          const childElement = document.querySelector(`.node[data-id="${childId}"]`);
          if (childElement) {
            // If parent is collapsed, hide the child regardless of its own state
            if (!node.expanded || isNodeHiddenByCollapse(nodeId)) {
              childElement.style.display = 'none';
            } else {
              childElement.style.display = 'block';
              // Recursively update children
              updateNodeVisibility(childId);
            }
          }
        }
      }
      
      // Redraw edges to reflect visibility changes
      drawEdges();
    }
    
    // Toggle expand/collapse for all nodes
    function toggleExpandCollapse() {
      const hasCollapsedNodes = Object.values(nodes).some(node => !node.expanded);
      
      // Toggle all nodes to the opposite state
      Object.values(nodes).forEach(node => {
        node.expanded = hasCollapsedNodes;
        const nodeElement = document.querySelector(`.node[data-id="${node.id}"]`);
        if (nodeElement) {
          if (node.expanded) {
            nodeElement.classList.remove('collapsed');
          } else {
            nodeElement.classList.add('collapsed');
          }
        }
      });
      
      // Update visibility for all nodes
      Object.keys(nodes).forEach(nodeId => {
        updateNodeVisibility(nodeId);
      });
      
      // Save to Firebase
      saveToFirebase();
    }
    
    // Initialize the app
    init();
  </script>
</body>
</html>